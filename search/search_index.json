{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Curso DJango Configuracion basica a caracteristicas avanzadas usando cosas nativas de python y paquets que se complementan perfecto con el framework django.","title":"Inicio"},{"location":"#curso-django","text":"Configuracion basica a caracteristicas avanzadas usando cosas nativas de python y paquets que se complementan perfecto con el framework django.","title":"Curso DJango"},{"location":"django/modelos/","text":"Gu\u00eda Completa de Models.py en Django Los modelos son el coraz\u00f3n de Django, actuando como la \u00fanica fuente de verdad sobre tus datos. Esta gu\u00eda exhaustiva cubre todo lo que puedes hacer con ellos, desde lo b\u00e1sico hasta t\u00e9cnicas avanzadas. 1. Definici\u00f3n b\u00e1sica de modelos from django.db import models class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) descripcion = models.TextField(blank=True) en_stock = models.BooleanField(default=True) fecha_creacion = models.DateTimeField(auto_now_add=True) def __str__(self): return self.nombre 2. Todos los tipos de campos disponibles Campos de texto # Cadenas cortas titulo = models.CharField(max_length=200) # Requerido especificar max_length codigo = models.SlugField(max_length=50) # Letras, n\u00fameros, guiones, guiones bajos nombre_usuario = models.SlugField(max_length=30, allow_unicode=True) # Permite Unicode # URLs y correos sitio_web = models.URLField(max_length=200) # Valida formato URL email = models.EmailField(max_length=254) # Valida formato email # Texto largo descripcion = models.TextField() # Texto ilimitado html_content = models.TextField(help_text=\"Contenido HTML de la p\u00e1gina\") Campos num\u00e9ricos # Enteros edad = models.IntegerField() # -2147483648 a 2147483647 cantidad = models.PositiveIntegerField() # 0 a 2147483647 plazas = models.PositiveSmallIntegerField() # 0 a 32767 poblacion = models.BigIntegerField() # -9223372036854775808 a 9223372036854775807 # Decimales precio = models.DecimalField(max_digits=10, decimal_places=2) # Precisi\u00f3n exacta altura = models.FloatField() # Coma flotante (menos preciso pero m\u00e1s r\u00e1pido) # Booleanos activo = models.BooleanField(default=True) enviado = models.BooleanField() Campos de fecha y hora fecha_nacimiento = models.DateField() hora_entrega = models.TimeField() fecha_hora_creacion = models.DateTimeField() fecha_modificacion = models.DateTimeField(auto_now=True) # Se actualiza en cada save() fecha_creacion = models.DateTimeField(auto_now_add=True) # Solo se establece en create() duracion = models.DurationField() # Para almacenar per\u00edodos de tiempo Campos de archivo # Archivos y im\u00e1genes documento = models.FileField(upload_to='documentos/') imagen = models.ImageField(upload_to='imagenes/%Y/%m/') # Requiere Pillow archivo_pdf = models.FileField( upload_to='pdfs/', validators=[FileExtensionValidator(allowed_extensions=['pdf'])] ) # Campos especializados para almacenar ubicaciones de archivos imagen_portada = models.FilePathField(path='/var/www/images/') Otros campos # Campos binarios datos = models.BinaryField() # Para almacenar datos binarios brutos # JSON y otros formatos configuracion = models.JSONField(default=dict) # Requiere PostgreSQL o similar # Campos especiales uuid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True) ip = models.GenericIPAddressField(protocol='both', unpack_ipv4=True) 3. Opciones comunes para todos los campos class Producto(models.Model): nombre = models.CharField( max_length=100, # Longitud m\u00e1xima (obligatorio para CharField) verbose_name=\"Nombre producto\", # Nombre legible para humanos help_text=\"Ingrese el nombre del producto\", # Texto de ayuda null=True, # Permite valores NULL en la BD blank=True, # Permite valores vac\u00edos en formularios default=\"Producto nuevo\", # Valor por defecto editable=False, # No se muestra en formularios unique=True, # Valor \u00fanico en la tabla db_index=True, # Crea \u00edndice en la BD para este campo primary_key=False, # No es clave primaria db_column=\"product_name\", # Nombre de columna espec\u00edfico en la BD choices=( # Lista predefinida de opciones ('S', 'Small'), ('M', 'Medium'), ('L', 'Large'), ), validators=[MinLengthValidator(3)], # Lista de validadores error_messages={ # Mensajes de error personalizados 'null': 'Este campo no puede ser nulo', 'blank': 'Este campo es obligatorio', } ) 4. Relaciones entre modelos ForeignKey (Relaci\u00f3n uno a muchos) class Categoria(models.Model): nombre = models.CharField(max_length=100) def __str__(self): return self.nombre class Producto(models.Model): # Muchos productos pueden pertenecer a una categor\u00eda categoria = models.ForeignKey( Categoria, # Modelo relacionado on_delete=models.CASCADE, # Comportamiento al eliminar: CASCADE, PROTECT, SET_NULL, SET_DEFAULT, DO_NOTHING, SET() related_name='productos', # Nombre para la relaci\u00f3n inversa related_query_name='producto', # Nombre para filtros en consultas inversas limit_choices_to={'activa': True}, # Limita las opciones disponibles db_constraint=True, # Crea restricci\u00f3n en la BD to_field='id', # Campo al que se relaciona (por defecto es pk) swappable=True, # Si se puede intercambiar el modelo relacionado db_index=True, # Crea \u00edndice para este campo null=True, # Permite nulos blank=True # Permite vac\u00edos en formularios ) # Auto-referencia (un producto puede ser el repuesto de otro) repuesto_de = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True) # Referencias a modelos a\u00fan no definidos creado_por = models.ForeignKey('auth.User', on_delete=models.PROTECT) ManyToManyField (Relaci\u00f3n muchos a muchos) class Etiqueta(models.Model): nombre = models.CharField(max_length=50) def __str__(self): return self.nombre class Producto(models.Model): # Un producto puede tener muchas etiquetas y una etiqueta puede estar en muchos productos etiquetas = models.ManyToManyField( Etiqueta, related_name='productos', blank=True, through='ProductoEtiqueta', # Modelo para la tabla intermedia personalizada through_fields=('producto', 'etiqueta'), # Campos para la relaci\u00f3n en el modelo through db_table='producto_etiqueta', # Nombre de la tabla intermedia en la BD symmetrical=False, # Para relaciones ManyToMany con 'self' ) # Auto-referencia (productos compatibles con este producto) compatible_con = models.ManyToManyField('self', blank=True, symmetrical=False) # Tabla intermedia personalizada para a\u00f1adir campos a la relaci\u00f3n class ProductoEtiqueta(models.Model): producto = models.ForeignKey(Producto, on_delete=models.CASCADE) etiqueta = models.ForeignKey(Etiqueta, on_delete=models.CASCADE) fecha_asignacion = models.DateTimeField(auto_now_add=True) asignado_por = models.ForeignKey('auth.User', on_delete=models.SET_NULL, null=True) class Meta: # Garantiza que no haya duplicados unique_together = [['producto', 'etiqueta']] OneToOneField (Relaci\u00f3n uno a uno) class Empleado(models.Model): nombre = models.CharField(max_length=100) apellido = models.CharField(max_length=100) class Perfil(models.Model): # Un perfil pertenece a un solo empleado y un empleado tiene un solo perfil empleado = models.OneToOneField( Empleado, on_delete=models.CASCADE, primary_key=True, # Usa el mismo ID que el empleado parent_link=True, # Para herencia multi-tabla ) fecha_nacimiento = models.DateField(null=True, blank=True) foto = models.ImageField(upload_to='perfiles/', null=True, blank=True) 5. M\u00e9todos y propiedades personalizados from django.utils import timezone import datetime class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) costo = models.DecimalField(max_digits=10, decimal_places=2) stock = models.PositiveIntegerField(default=0) fecha_caducidad = models.DateField(null=True, blank=True) # Propiedad calculada @property def margen(self): \"\"\"Calcula el margen de beneficio\"\"\" if self.costo == 0: return 0 return ((self.precio - self.costo) / self.precio) * 100 # Propiedad con setter @property def precio_con_iva(self): \"\"\"Precio con IVA incluido\"\"\" return self.precio * 1.21 @precio_con_iva.setter def precio_con_iva(self, valor): \"\"\"Establece el precio sin IVA a partir del precio con IVA\"\"\" self.precio = valor / 1.21 # M\u00e9todo de instancia def esta_disponible(self): \"\"\"Determina si el producto est\u00e1 disponible\"\"\" if self.stock <= 0: return False if self.fecha_caducidad and self.fecha_caducidad <= timezone.now().date(): return False return True # M\u00e9todo con par\u00e1metros def aplicar_descuento(self, porcentaje): \"\"\"Aplica un descuento al precio del producto\"\"\" if porcentaje < 0 or porcentaje > 100: raise ValueError(\"El porcentaje debe estar entre 0 y 100\") self.precio = self.precio * (1 - (porcentaje / 100)) return self.precio # M\u00e9todo que modifica m\u00faltiples campos def recibir_stock(self, cantidad, nuevo_costo=None): \"\"\"A\u00f1ade stock y actualiza el costo si se proporciona\"\"\" if cantidad <= 0: raise ValueError(\"La cantidad debe ser positiva\") self.stock += cantidad if nuevo_costo is not None: self.costo = nuevo_costo self.save(update_fields=['stock', 'costo']) return self.stock # M\u00e9todo que interact\u00faa con otras instancias def transferir_stock(self, producto_destino, cantidad): \"\"\"Transfiere stock a otro producto\"\"\" if cantidad <= 0: raise ValueError(\"La cantidad debe ser positiva\") if cantidad > self.stock: raise ValueError(\"Stock insuficiente\") self.stock -= cantidad producto_destino.stock += cantidad self.save(update_fields=['stock']) producto_destino.save(update_fields=['stock']) # M\u00e9todo que devuelve un valor complejo o QuerySet def obtener_productos_similares(self): \"\"\"Encuentra productos con precios similares\"\"\" min_precio = self.precio * 0.9 max_precio = self.precio * 1.1 return Producto.objects.filter( precio__gte=min_precio, precio__lte=max_precio ).exclude(id=self.id) 6. M\u00e9todos est\u00e1ticos y de clase class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) # M\u00e9todo est\u00e1tico (no accede a la instancia ni a la clase) @staticmethod def convertir_moneda(precio, tasa_cambio): \"\"\"Convierte un precio a otra moneda usando la tasa de cambio\"\"\" return precio * tasa_cambio # M\u00e9todo de clase (accede a la clase pero no a la instancia) @classmethod def crear_oferta(cls, nombre, precio_original, descuento_porcentaje): \"\"\"Crea un nuevo producto con descuento aplicado\"\"\" precio_con_descuento = precio_original * (1 - (descuento_porcentaje / 100)) return cls.objects.create( nombre=f\"{nombre} (Oferta {descuento_porcentaje}%)\", precio=precio_con_descuento ) # M\u00e9todo de clase que devuelve un QuerySet @classmethod def obtener_productos_caros(cls): \"\"\"Obtiene productos con precio superior a la media\"\"\" from django.db.models import Avg precio_medio = cls.objects.aggregate(Avg('precio'))['precio__avg'] return cls.objects.filter(precio__gt=precio_medio) 7. Sobreescritura de m\u00e9todos del modelo class Producto(models.Model): nombre = models.CharField(max_length=100) slug = models.SlugField(unique=True) # Personalizar representaci\u00f3n en string def __str__(self): return f\"{self.nombre} ({self.id})\" # Personalizar representaci\u00f3n en depuraci\u00f3n def __repr__(self): return f\"<Producto: {self.id}, {self.nombre}>\" # Personalizar el comportamiento de guardado def save(self, *args, **kwargs): # Acciones antes de guardar if not self.slug: from django.utils.text import slugify self.slug = slugify(self.nombre) # Validaciones personalizadas if len(self.nombre) < 3: raise ValueError(\"El nombre debe tener al menos 3 caracteres\") # Llamar al m\u00e9todo original super().save(*args, **kwargs) # Acciones despu\u00e9s de guardar self.crear_thumbnail() # Personalizar el comportamiento de eliminaci\u00f3n def delete(self, *args, **kwargs): # Acciones antes de eliminar self.eliminar_archivos_asociados() # Llamar al m\u00e9todo original super().delete(*args, **kwargs) # Acciones despu\u00e9s de eliminar (cuidado: la instancia ya no existe en la BD) # Personalizar el comportamiento de validaci\u00f3n def clean(self): \"\"\"Validaciones a nivel de modelo (no de campo)\"\"\" from django.core.exceptions import ValidationError if self.precio < self.costo: raise ValidationError(\"El precio no puede ser menor que el costo\") if self.fecha_inicio and self.fecha_fin and self.fecha_inicio > self.fecha_fin: raise ValidationError({ 'fecha_inicio': \"La fecha de inicio no puede ser posterior a la fecha de fin\", 'fecha_fin': \"La fecha de fin no puede ser anterior a la fecha de inicio\" }) # Personalizar URLs def get_absolute_url(self): \"\"\"Devuelve la URL \u00fanica para este objeto\"\"\" from django.urls import reverse return reverse('producto-detalle', kwargs={'slug': self.slug}) 8. Meta opciones class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) class Meta: # Nombre y plurales para la interfaz de administraci\u00f3n verbose_name = \"Producto\" verbose_name_plural = \"Productos\" # Ordenaci\u00f3n por defecto ordering = ['-fecha_creacion', 'nombre'] # \u00cdndices para optimizar consultas indexes = [ models.Index(fields=['nombre']), models.Index(fields=['precio', 'categoria']), models.Index(fields=['-fecha_creacion'], name='idx_fecha_creacion_desc'), ] # Restricciones de unicidad compuesta unique_together = [['sku', 'tienda'], ['slug', 'categoria']] # Restricciones de unicidad con condiciones (Django 2.2+) constraints = [ models.UniqueConstraint( fields=['sku', 'tienda'], name='unique_sku_por_tienda' ), models.UniqueConstraint( fields=['slug'], condition=models.Q(activo=True), name='unique_slug_activos' ), models.CheckConstraint( check=models.Q(precio__gte=0), name='precio_positivo' ), ] # Nombrar la tabla en la base de datos db_table = 'inventario_producto' # Otras opciones Meta abstract = False # Si es True, ser\u00e1 un modelo abstracto app_label = 'inventario' # Especifica la app a la que pertenece db_tablespace = 'idx_tbls' # Espacio de tabla para \u00edndices default_permissions = ('add', 'change', 'delete', 'view') default_related_name = 'productos' # Nombre relacional por defecto get_latest_by = 'fecha_creacion' # Campo para latest() y earliest() managed = True # Si Django gestiona esta tabla order_with_respect_to = 'categoria' # Permite ordenar respecto a otro campo permissions = [ # Permisos adicionales ('puede_publicar', 'Puede publicar productos'), ('puede_destacar', 'Puede destacar productos'), ] proxy = False # Si es modelo proxy required_db_features = ['supports_json_field'] # Caracter\u00edsticas requeridas de la BD select_on_save = False # Si hacer SELECT antes de guardar 9. Managers personalizados class ProductoActivoManager(models.Manager): \"\"\"Manager que solo devuelve productos activos\"\"\" def get_queryset(self): return super().get_queryset().filter(activo=True) # M\u00e9todo personalizado del manager def destacados(self): \"\"\"Devuelve productos activos y destacados\"\"\" return self.filter(destacado=True) # M\u00e9todo para crear objetos con valores por defecto def crear_producto_destacado(self, nombre, precio, **kwargs): return self.create( nombre=nombre, precio=precio, destacado=True, **kwargs ) class ProductoDesactivoManager(models.Manager): \"\"\"Manager que solo devuelve productos inactivos\"\"\" def get_queryset(self): return super().get_queryset().filter(activo=False) class ProductoQuerySet(models.QuerySet): \"\"\"QuerySet personalizado con m\u00e9todos adicionales\"\"\" def destacados(self): return self.filter(destacado=True) def por_precio(self, precio_min, precio_max): return self.filter(precio__gte=precio_min, precio__lte=precio_max) def agotados(self): return self.filter(stock=0) # M\u00e9todos que modifiquen datos en masa def destacar_todos(self): return self.update(destacado=True) def subir_precio(self, porcentaje): from django.db.models import F return self.update(precio=F('precio') * (1 + porcentaje/100)) class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) stock = models.PositiveIntegerField(default=0) activo = models.BooleanField(default=True) destacado = models.BooleanField(default=False) # Manager por defecto objects = models.Manager() # Managers adicionales activos = ProductoActivoManager() inactivos = ProductoDesactivoManager() # Manager personalizado que devuelve QuerySet personalizado todo = models.Manager.from_queryset(ProductoQuerySet)() def __str__(self): return self.nombre Ahora podemos usar: # Usando los diferentes managers Producto.objects.all() # Todos los productos Producto.activos.all() # Solo productos activos Producto.inactivos.all() # Solo productos inactivos Producto.activos.destacados() # Productos activos y destacados # Usando el QuerySet personalizado Producto.todo.destacados() Producto.todo.por_precio(10, 100) Producto.todo.agotados() # Operaciones en masa Producto.todo.filter(categoria=5).destacar_todos() Producto.todo.filter(marca=\"Sony\").subir_precio(5) 10. Herencia de modelos Herencia abstracta class ModeloBase(models.Model): \"\"\"Modelo abstracto con campos comunes\"\"\" creado = models.DateTimeField(auto_now_add=True) modificado = models.DateTimeField(auto_now=True) activo = models.BooleanField(default=True) class Meta: abstract = True # No crea tabla para este modelo def activar(self): self.activo = True self.save(update_fields=['activo']) def desactivar(self): self.activo = False self.save(update_fields=['activo']) class Producto(ModeloBase): \"\"\"Hereda todos los campos y m\u00e9todos de ModeloBase\"\"\" nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) # Puede a\u00f1adir sus propias Meta opciones class Meta(ModeloBase.Meta): verbose_name = \"Producto\" ordering = ['-creado'] class Cliente(ModeloBase): \"\"\"Tambi\u00e9n hereda de ModeloBase\"\"\" nombre = models.CharField(max_length=100) email = models.EmailField() Herencia multi-tabla class Producto(models.Model): \"\"\"Modelo base para todos los productos\"\"\" nombre = models.CharField(max_length=100) descripcion = models.TextField(blank=True) precio = models.DecimalField(max_digits=10, decimal_places=2) def __str__(self): return self.nombre class Libro(Producto): \"\"\"Crea una tabla separada con un OneToOneField a Producto\"\"\" autor = models.CharField(max_length=100) isbn = models.CharField(max_length=13) paginas = models.PositiveIntegerField() def __str__(self): return f\"{self.nombre} de {self.autor}\" class Electronico(Producto): \"\"\"Otra tabla separada con relaci\u00f3n a Producto\"\"\" marca = models.CharField(max_length=50) modelo = models.CharField(max_length=50) garantia_meses = models.PositiveIntegerField() def __str__(self): return f\"{self.marca} {self.modelo}\" Herencia proxy class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) tipo = models.CharField(max_length=20, choices=[ ('normal', 'Normal'), ('destacado', 'Destacado'), ('oferta', 'Oferta') ]) def __str__(self): return self.nombre class ProductoDestacado(Producto): \"\"\" Modelo proxy que no crea nueva tabla, sino que proporciona una vista diferente del modelo Producto \"\"\" objects = models.Manager() # Manager por defecto class Meta: proxy = True # Es un modelo proxy ordering = ['-precio'] # Ordenaci\u00f3n diferente def destacar(self): self.tipo = 'destacado' self.save() @property def precio_original(self): \"\"\"Calcula el precio original antes del descuento\"\"\" return self.precio * 1.2 11. Se\u00f1ales (Signals) # En models.py o en signals.py from django.db.models.signals import pre_save, post_save, pre_delete, post_delete from django.dispatch import receiver from .models import Producto @receiver(pre_save, sender=Producto) def producto_pre_save(sender, instance, **kwargs): \"\"\"Se ejecuta antes de guardar un producto\"\"\" # Podemos modificar la instancia antes de guardarla if instance.stock < 0: instance.stock = 0 # Calcular campos derivados if instance.precio and instance.costo: instance.margen = instance.precio - instance.costo @receiver(post_save, sender=Producto) def producto_post_save(sender, instance, created, **kwargs): \"\"\"Se ejecuta despu\u00e9s de guardar un producto\"\"\" if created: # Solo si es un producto nuevo from .tasks import notificar_nuevo_producto notificar_nuevo_producto.delay(instance.id) else: # Si es una actualizaci\u00f3n if 'precio' in kwargs.get('update_fields', []): from .tasks import actualizar_precios_relacionados actualizar_precios_relacionados.delay(instance.id) @receiver(pre_delete, sender=Producto) def producto_pre_delete(sender, instance, **kwargs): \"\"\"Se ejecuta antes de eliminar un producto\"\"\" # Guardar registro de eliminaci\u00f3n from .models import RegistroEliminacion RegistroEliminacion.objects.create( modelo='Producto', objeto_id=instance.id, nombre=instance.nombre, datos=str(instance.__dict__) ) # Eliminar archivos asociados if instance.imagen: import os if os.path.isfile(instance.imagen.path): os.remove(instance.imagen.path) @receiver(post_delete, sender=Producto) def producto_post_delete(sender, instance, **kwargs): \"\"\"Se ejecuta despu\u00e9s de eliminar un producto\"\"\" # Actualizar cach\u00e9 o b\u00fasqueda from .tasks import actualizar_cache_productos actualizar_cache_productos.delay() # Se\u00f1ales personalizadas from django.dispatch import Signal # Definir una se\u00f1al personalizada producto_agotado = Signal() # Puede incluir providing_args=['producto'] class Venta(models.Model): producto = models.ForeignKey(Producto, on_delete=models.CASCADE) cantidad = models.PositiveIntegerField() def save(self, *args, **kwargs): super().save(*args, **kwargs) # Actualizar stock self.producto.stock -= self.cantidad self.producto.save(update_fields=['stock']) # Emitir se\u00f1al si el producto se agot\u00f3 if self.producto.stock == 0: producto_agotado.send(sender=self.__class__, producto=self.producto) # En otro lugar, escuchar la se\u00f1al personalizada @receiver(producto_agotado) def notificar_producto_agotado(sender, producto, **kwargs): from django.core.mail import send_mail send_mail( f'Producto agotado: {producto.nombre}', f'El producto {producto.nombre} se ha agotado.', 'sistema@ejemplo.com', ['almacen@ejemplo.com'], ) 12. Campos personalizados from django.db import models from django.core.exceptions import ValidationError def validar_rango(value): if value < 0 or value > 100: raise ValidationError('El valor debe estar entre 0 y 100') class RangoEnteroField(models.IntegerField): \"\"\"Campo entero con validaci\u00f3n de rango personalizada\"\"\" def __init__(self, min_value=None, max_value=None, *args, **kwargs): self.min_value = min_value self.max_value = max_value super().__init__(*args, **kwargs) def formfield(self, **kwargs): # Personaliza el campo de formulario defaults = { 'min_value': self.min_value, 'max_value': self.max_value, } defaults.update(kwargs) return super().formfield(**defaults) def deconstruct(self): # Necesario para las migraciones name, path, args, kwargs = super().deconstruct() if self.min_value is not None: kwargs['min_value'] = self.min_value if self.max_value is not None: kwargs['max_value'] = self.max_value return name, path, args, kwargs def validate(self, value, model_instance): # Validaci\u00f3n personalizada super().validate(value, model_instance) if self.min_value is not None and value < self.min_value: raise ValidationError(f'El valor debe ser mayor o igual a {self.min_value}') if self.max_value is not None and value > self.max_value: raise ValidationError(f'El valor debe ser menor o igual a {self.max_value}') class ColorField(models.CharField): \"\"\"Campo para almacenar colores en formato hexadecimal\"\"\" def __init__(self, *args, **kwargs): kwargs['max_length'] = 7 super().__init__(*args, **kwargs) def clean(self, value, model_instance): value = super().clean(value, model_instance) if value and not value.startswith('#'): value = f'#{value}' return value def validate(self, value, model_instance): super().validate(value, model_instance) if value: import re if not re.match(r'^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$', value): raise ValidationError('Formato de color hexadecimal inv\u00e1lido') class Producto(models.Model): nombre = models.CharField(max_length=100) calificacion = RangoEnteroField(min_value=1, max_value=5, help_text=\"Calificaci\u00f3n de 1 a 5 estrellas\") color_principal = ColorField(null=True, blank=True, help_text=\"Color en formato hexadecimal (#RRGGBB)\") 13. Operaciones avanzadas con QuerySets from django.db.models import F, Q, Count, Sum, Avg, Min, Max, Case, When, Value, IntegerField, CharField from django.db.models.functions import ExtractYear, ExtractMonth, Concat class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) stock = models.PositiveIntegerField(default=0) categoria = models.ForeignKey('Categoria', on_delete=models.CASCADE) fecha_creacion = models.DateTimeField(auto_now_add=True) @classmethod def consultas_avanzadas(cls): # Ejemplos de consultas avanzadas # F expressions - Operaciones a nivel de base de datos cls.objects.update(precio=F('precio') * 1.1) # Aumenta todos los precios un 10% # Productos cuyo precio es mayor que el precio base productos_caros = cls.objects.filter(precio__gt=F('precio_base')) # Productos con m\u00e1s ventas que stock productos_exitosos = cls.objects.filter(ventas_totales__gt=F('stock')) # Q expressions - Consultas complejas con OR, AND, NOT from django.db.models import Q # Productos baratos O con stock alto productos = cls.objects.filter( Q(precio__lt=10) | Q(stock__gt=100) ) # Productos caros Y de categor\u00eda espec\u00edfica, excluyendo una marca productos = cls.objects.filter( Q(precio__gt=50) & Q(categoria__nombre='Electr\u00f3nica') & ~Q(marca='Marca Gen\u00e9rica') ) # Funciones de agregaci\u00f3n from django.db.models import Avg, Count, Min, Max, Sum # Estad\u00edsticas generales stats = cls.objects.aggregate( total_productos=Count('id'), precio_promedio=Avg('precio'), precio_minimo=Min('precio'), precio_maximo=Max('precio'), valor_inventario=Sum(F('precio') * F('stock')) ) # Anotaciones - A\u00f1adir campos calculados a cada objeto productos = cls.objects.annotate( valor_total=F('precio') * F('stock'), descuento=F('precio_base') - F('precio'), porcentaje_descuento=(F('precio_base') - F('precio')) * 100 / F('precio_base') ) # Anotaciones con Count productos = cls.objects.annotate( num_reviews=Count('review'), num_ventas=Count('venta') ) # Anotaciones con Case/When (if/else condicionales) from django.db.models import Case, When, Value, IntegerField productos = cls.objects.annotate( estado_stock=Case( When(stock=0, then=Value('Agotado')), When(stock__lt=10, then=Value('Bajo')), When(stock__lt=50, then=Value('Medio')), default=Value('Alto'), output_field=CharField() ) ) # Agrupaci\u00f3n (GROUP BY) from django.db.models.functions import ExtractYear, ExtractMonth # Ventas por a\u00f1o y mes ventas_por_mes = cls.objects.annotate( a\u00f1o=ExtractYear('fecha_venta'), mes=ExtractMonth('fecha_venta') ).values('a\u00f1o', 'mes').annotate( total_ventas=Sum('cantidad'), ingresos=Sum(F('cantidad') * F('precio_unitario')) ).order_by('a\u00f1o', 'mes') # Concatenaci\u00f3n de campos from django.db.models.functions import Concat from django.db.models import Value productos = cls.objects.annotate( nombre_completo=Concat( 'nombre', Value(' - '), 'marca', Value(' ('), 'categoria__nombre', Value(')') ) ) return \"Ejemplos de consultas avanzadas de QuerySets\" 14. Consultas y joins complejos class Producto(models.Model): nombre = models.CharField(max_length=100) categoria = models.ForeignKey('Categoria', on_delete=models.CASCADE) @classmethod def consultas_complejas(cls): # select_related - Para relaciones ForeignKey y OneToOne productos = cls.objects.select_related('categoria', 'marca') # Ahora podemos acceder a producto.categoria.nombre sin consultas adicionales for producto in productos: print(f\"{producto.nombre} - {producto.categoria.nombre}\") # prefetch_related - Para relaciones ManyToMany y \"relaciones inversas\" productos = cls.objects.prefetch_related('etiquetas', 'reviews') # Prefetch con Prefetch - Para personalizar la consulta prefetch from django.db.models import Prefetch productos = cls.objects.prefetch_related( Prefetch( 'reviews', queryset=Review.objects.filter(rating__gte=4).select_related('usuario'), to_attr='buenas_reviews' ) ) # Consultas complejas con select_related + prefetch_related productos = cls.objects.select_related( 'categoria', 'marca' ).prefetch_related( 'etiquetas', Prefetch('reviews', queryset=Review.objects.select_related('usuario')) ) # Consultas con joins expl\u00edcitos from django.db.models import OuterRef, Subquery # Subconsulta - \u00daltima review de cada producto ultima_review = Review.objects.filter( producto=OuterRef('pk') ).order_by('-fecha_creacion').values('texto')[:1] productos = cls.objects.annotate( ultima_review=Subquery(ultima_review) ) # Consultas en bruto (raw SQL) productos = cls.objects.raw(\"\"\" SELECT p.*, c.nombre as categoria_nombre FROM producto p JOIN categoria c ON p.categoria_id = c.id WHERE p.precio > 100 ORDER BY p.nombre \"\"\") # Usando extra() para a\u00f1adir JOIN, WHERE o SELECT productos = cls.objects.extra( select={'categoria_nombre': 'categoria.nombre'}, tables=['categoria'], where=['producto.categoria_id = categoria.id', 'producto.precio > 100'] ) return \"Ejemplos de consultas y joins complejos\" 15. Transacciones y operaciones at\u00f3micas from django.db import transaction class Venta(models.Model): producto = models.ForeignKey('Producto', on_delete=models.CASCADE) cantidad = models.PositiveIntegerField() @classmethod def realizar_venta(cls, producto_id, cantidad, cliente_id): # Transacci\u00f3n at\u00f3mica decorando funci\u00f3n @transaction.atomic def _realizar_venta(): # Todo esto ocurre dentro de una transacci\u00f3n producto = Producto.objects.select_for_update().get(id=producto_id) if producto.stock < cantidad: raise ValueError(\"Stock insuficiente\") # Actualizar stock producto.stock -= cantidad producto.save(update_fields=['stock']) # Crear venta venta = cls.objects.create( producto=producto, cantidad=cantidad, cliente_id=cliente_id ) # Actualizar estad\u00edsticas ProductoEstadistica.objects.update_or_create( producto=producto, defaults={'total_vendido': F('total_vendido') + cantidad} ) return venta return _realizar_venta() @classmethod def otro_ejemplo_transacciones(cls): # Usando with para bloques de transacci\u00f3n try: with transaction.atomic(): # Todo dentro de este bloque es parte de la misma transacci\u00f3n producto1 = Producto.objects.select_for_update().get(id=1) producto1.stock -= 1 producto1.save() producto2 = Producto.objects.select_for_update().get(id=2) producto2.stock -= 1 if producto2.stock < 0: # Si hay un error, toda la transacci\u00f3n se deshace raise ValueError(\"Stock insuficiente para producto 2\") producto2.save() except Exception as e: # La transacci\u00f3n se ha deshecho, ning\u00fan cambio se guard\u00f3 return f\"Error en la transacci\u00f3n: {str(e)}\" # Puntos de guardado (savepoints) with transaction.atomic(): # Punto de guardado 1 sid1 = transaction.savepoint() producto1 = Producto.objects.get(id=1) producto1.stock -= 1 producto1.save() if alguna_condicion: # Deshacer hasta el punto de guardado 1 transaction.savepoint_rollback(sid1) else: # Confirmar el punto de guardado 1 transaction.savepoint_commit(sid1) # Punto de guardado 2 sid2 = transaction.savepoint() try: producto2 = Producto.objects.get(id=2) producto2.stock -= 1 producto2.save() except: # Deshacer hasta el punto de guardado 2 transaction.savepoint_rollback(sid2) return \"Ejemplos de transacciones\" 16. \u00cdndices, Constraints y Referencias complejas class Categoria(models.Model): nombre = models.CharField(max_length=100) class Meta: verbose_name_plural = \"Categor\u00edas\" class Producto(models.Model): nombre = models.CharField(max_length=100) sku = models.CharField(max_length=20) precio = models.DecimalField(max_digits=10, decimal_places=2) categoria = models.ForeignKey( Categoria, on_delete=models.PROTECT, # No permite eliminar categor\u00edas con productos related_name='productos' ) proveedor = models.ForeignKey( 'Proveedor', on_delete=models.SET_NULL, # Permite eliminar proveedores, poniendo NULL null=True, blank=True ) productos_relacionados = models.ManyToManyField( 'self', # Relaci\u00f3n a s\u00ed mismo symmetrical=False, # A->B no implica B->A blank=True ) # \u00cdndices simples y compuestos (Django 2.2+) class Meta: indexes = [ models.Index(fields=['nombre']), models.Index(fields=['categoria', 'precio']), models.Index(fields=['sku'], name='idx_producto_sku'), # \u00cdndice parcial solo para productos activos models.Index( fields=['nombre'], name='idx_producto_activo_nombre', condition=models.Q(activo=True) ), # \u00cdndice para b\u00fasqueda de texto models.Index( name='idx_producto_busqueda', fields=['nombre', 'descripcion'], opclasses=['varchar_pattern_ops', 'text_pattern_ops'] ), ] # Constraints complejas (Django 2.2+) constraints = [ # Restricci\u00f3n de unicidad models.UniqueConstraint( fields=['sku', 'proveedor'], name='uq_producto_sku_proveedor' ), # Restricci\u00f3n de unicidad condicional models.UniqueConstraint( fields=['slug'], condition=models.Q(activo=True), name='uq_producto_activo_slug' ), # Restricci\u00f3n CHECK models.CheckConstraint( check=models.Q(precio__gt=0), name='chk_producto_precio_positivo' ), models.CheckConstraint( check=models.Q(fecha_fin__gt=models.F('fecha_inicio')), name='chk_producto_fechas_validas' ), ] 17. Funciones de B\u00fasqueda y Expresiones Avanzadas from django.db.models import F, Func, Value from django.db.models.functions import Concat, Lower, Upper, Substr, Length, Replace, ExtractYear, Cast from django.db.models import CharField, IntegerField, DateField class Producto(models.Model): nombre = models.CharField(max_length=100) descripcion = models.TextField() precio = models.DecimalField(max_digits=10, decimal_places=2) fecha_creacion = models.DateTimeField(auto_now_add=True) @classmethod def funciones_avanzadas(cls): # Operaciones con texto productos = cls.objects.annotate( # Concatenaci\u00f3n titulo_completo=Concat( 'nombre', Value(' - '), 'categoria__nombre', output_field=CharField() ), # Min\u00fasculas y may\u00fasculas nombre_lower=Lower('nombre'), nombre_upper=Upper('nombre'), # Subcadenas primera_letra=Substr('nombre', 1, 1), # Longitud longitud_nombre=Length('nombre'), # Reemplazo sin_espacios=Replace('nombre', Value(' '), Value('_')) ) # Operaciones con fecha productos = cls.objects.annotate( # Extraer componentes de fecha a\u00f1o=ExtractYear('fecha_creacion'), mes=ExtractMonth('fecha_creacion'), # Diferencia entre fechas dias_activo=Cast( Now() - F('fecha_creacion'), output_field=DurationField() ) ) # Funciones matem\u00e1ticas from django.db.models.functions import Abs, Ceil, Floor, Round, Sin, Cos, Sqrt, Power productos = cls.objects.annotate( precio_redondeado=Round('precio'), precio_techo=Ceil('precio'), precio_suelo=Floor('precio'), precio_absoluto=Abs('precio'), precio_raiz=Sqrt('precio'), precio_cuadrado=Power('precio', 2) ) # Creando funciones personalizadas class GroupConcat(Func): function = 'GROUP_CONCAT' template = '%(function)s(%(expressions)s)' # Usando funciones SQL directamente from django.db.models.expressions import RawSQL productos = cls.objects.annotate( distancia=RawSQL( \"ST_Distance(ubicacion, ST_SetSRID(ST_MakePoint(%s, %s), 4326))\", (longitude, latitude) ) ).order_by('distancia') return \"Ejemplos de expresiones y funciones avanzadas\" 18. Opciones de Definici\u00f3n de Modelos menos comunes class ProductoPersonalizado(models.Model): # Campo proxy que apunta a otro modelo pero con un nombre diferente categoria = models.ForeignKey( 'Categoria', on_delete=models.CASCADE, db_column='categoria_id', # Nombre de columna en la BD to_field='codigo_categoria', # Campo en Categoria (no es la PK) related_name='mis_productos', # Nombre de la relaci\u00f3n inversa related_query_name='mi_producto', # Nombre para filtros inversos limit_choices_to={'activa': True}, # Limita las opciones disponibles swappable=True, # Si el modelo relacionado es intercambiable ) # Definir un Manager de forma expl\u00edcita con una funci\u00f3n def productos_activos(): return models.Manager().from_queryset( lambda self: self.filter(activo=True) )() activos = productos_activos() # Opciones menos comunes para campos codigo_promocional = models.CharField( max_length=10, db_collation='utf8_bin', # Collation espec\u00edfica (sensible a may\u00fasculas/min\u00fasculas) db_index=True, # \u00cdndice en la BD para este campo ) # Campo con restricciones de BD pero sin restricciones en Python codigo_interno = models.CharField( max_length=50, db_column='internal_code', # Nombre en la BD error_messages={ # Mensajes de error personalizados 'blank': 'Este campo no puede estar vac\u00edo.', 'unique': 'Ya existe un producto con este c\u00f3digo interno.' } ) # Definir una PK personalizada codigo_unico = models.CharField( max_length=20, primary_key=True, # Este campo es la PK editable=False, # No se puede editar desde el admin ) class Meta: # Definir permisos a nivel de modelo default_permissions = ('add', 'change', 'delete', 'view') permissions = [ ('puede_publicar', 'Puede publicar productos'), ('puede_comprar', 'Puede comprar productos'), ] # Definir \u00edndice funcional indexes = [ models.Index( Lower('nombre'), name='idx_lower_nombre' ) ] # Controlar si Django maneja las tablas managed = True # Django gestiona esta tabla # Definir vistas de base de datos managed = False # Para usar con vistas de BD db_table = 'productos_activos_view' # Vista definida en la BD 19. Integraci\u00f3n con otros sistemas y ORM avanzado # Integraci\u00f3n con PostgreSQL - Campos espec\u00edficos from django.contrib.postgres.fields import ArrayField, HStoreField, JSONField from django.contrib.postgres.search import SearchVectorField, SearchVector, SearchQuery, SearchRank from django.contrib.postgres.indexes import GinIndex class ProductoPostgreSQL(models.Model): nombre = models.CharField(max_length=100) tags = ArrayField( models.CharField(max_length=50), size=10, # Limita a 10 elementos blank=True, # Permite array vac\u00edo default=list # Valor por defecto ) atributos = HStoreField(default=dict) # Diccionario clave-valor metadatos = JSONField(default=dict) # Campo JSON # Para b\u00fasqueda de texto completo search_vector = SearchVectorField(null=True) class Meta: indexes = [ GinIndex(fields=['search_vector']) # \u00cdndice GIN para b\u00fasqueda r\u00e1pida ] def save(self, *args, **kwargs): # Actualiza el vector de b\u00fasqueda al guardar self.search_vector = ( SearchVector('nombre', weight='A') + SearchVector('descripcion', weight='B') ) super().save(*args, **kwargs) @classmethod def buscar(cls, consulta): search_query = SearchQuery(consulta) return cls.objects.annotate( rank=SearchRank(F('search_vector'), search_query) ).filter( search_vector=search_query ).order_by('-rank') @classmethod def consultas_especiales_postgres(cls): # Consulta en array (contiene elementos) productos = cls.objects.filter(tags__contains=['oferta', 'nuevo']) # Consulta en json/hstore productos = cls.objects.filter(metadatos__contains={'color': 'rojo'}) productos = cls.objects.filter(metadatos__color='rojo') # Conteo de elementos array from django.contrib.postgres.aggregates import ArrayLength productos = cls.objects.annotate( num_tags=ArrayLength('tags', 1) # 1 indica dimensi\u00f3n del array ).filter(num_tags__gt=3) return \"Consultas especiales PostgreSQL\" # Modelos no mapeados directamente a tablas class VentasReporte(models.Model): \"\"\"Modelo para manejar reportes complejos sin tabla directa\"\"\" class Meta: managed = False # No crea tabla @classmethod def ventas_por_mes(cls, a\u00f1o): \"\"\"Obtiene datos que no corresponden a un solo modelo\"\"\" return Venta.objects.filter( fecha__year=a\u00f1o ).annotate( mes=ExtractMonth('fecha') ).values('mes').annotate( total=Sum('total') ).order_by('mes')","title":"Modelos"},{"location":"django/modelos/#guia-completa-de-modelspy-en-django","text":"Los modelos son el coraz\u00f3n de Django, actuando como la \u00fanica fuente de verdad sobre tus datos. Esta gu\u00eda exhaustiva cubre todo lo que puedes hacer con ellos, desde lo b\u00e1sico hasta t\u00e9cnicas avanzadas.","title":"Gu\u00eda Completa de Models.py en Django"},{"location":"django/modelos/#1-definicion-basica-de-modelos","text":"from django.db import models class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) descripcion = models.TextField(blank=True) en_stock = models.BooleanField(default=True) fecha_creacion = models.DateTimeField(auto_now_add=True) def __str__(self): return self.nombre","title":"1. Definici\u00f3n b\u00e1sica de modelos"},{"location":"django/modelos/#2-todos-los-tipos-de-campos-disponibles","text":"","title":"2. Todos los tipos de campos disponibles"},{"location":"django/modelos/#campos-de-texto","text":"# Cadenas cortas titulo = models.CharField(max_length=200) # Requerido especificar max_length codigo = models.SlugField(max_length=50) # Letras, n\u00fameros, guiones, guiones bajos nombre_usuario = models.SlugField(max_length=30, allow_unicode=True) # Permite Unicode # URLs y correos sitio_web = models.URLField(max_length=200) # Valida formato URL email = models.EmailField(max_length=254) # Valida formato email # Texto largo descripcion = models.TextField() # Texto ilimitado html_content = models.TextField(help_text=\"Contenido HTML de la p\u00e1gina\")","title":"Campos de texto"},{"location":"django/modelos/#campos-numericos","text":"# Enteros edad = models.IntegerField() # -2147483648 a 2147483647 cantidad = models.PositiveIntegerField() # 0 a 2147483647 plazas = models.PositiveSmallIntegerField() # 0 a 32767 poblacion = models.BigIntegerField() # -9223372036854775808 a 9223372036854775807 # Decimales precio = models.DecimalField(max_digits=10, decimal_places=2) # Precisi\u00f3n exacta altura = models.FloatField() # Coma flotante (menos preciso pero m\u00e1s r\u00e1pido) # Booleanos activo = models.BooleanField(default=True) enviado = models.BooleanField()","title":"Campos num\u00e9ricos"},{"location":"django/modelos/#campos-de-fecha-y-hora","text":"fecha_nacimiento = models.DateField() hora_entrega = models.TimeField() fecha_hora_creacion = models.DateTimeField() fecha_modificacion = models.DateTimeField(auto_now=True) # Se actualiza en cada save() fecha_creacion = models.DateTimeField(auto_now_add=True) # Solo se establece en create() duracion = models.DurationField() # Para almacenar per\u00edodos de tiempo","title":"Campos de fecha y hora"},{"location":"django/modelos/#campos-de-archivo","text":"# Archivos y im\u00e1genes documento = models.FileField(upload_to='documentos/') imagen = models.ImageField(upload_to='imagenes/%Y/%m/') # Requiere Pillow archivo_pdf = models.FileField( upload_to='pdfs/', validators=[FileExtensionValidator(allowed_extensions=['pdf'])] ) # Campos especializados para almacenar ubicaciones de archivos imagen_portada = models.FilePathField(path='/var/www/images/')","title":"Campos de archivo"},{"location":"django/modelos/#otros-campos","text":"# Campos binarios datos = models.BinaryField() # Para almacenar datos binarios brutos # JSON y otros formatos configuracion = models.JSONField(default=dict) # Requiere PostgreSQL o similar # Campos especiales uuid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True) ip = models.GenericIPAddressField(protocol='both', unpack_ipv4=True)","title":"Otros campos"},{"location":"django/modelos/#3-opciones-comunes-para-todos-los-campos","text":"class Producto(models.Model): nombre = models.CharField( max_length=100, # Longitud m\u00e1xima (obligatorio para CharField) verbose_name=\"Nombre producto\", # Nombre legible para humanos help_text=\"Ingrese el nombre del producto\", # Texto de ayuda null=True, # Permite valores NULL en la BD blank=True, # Permite valores vac\u00edos en formularios default=\"Producto nuevo\", # Valor por defecto editable=False, # No se muestra en formularios unique=True, # Valor \u00fanico en la tabla db_index=True, # Crea \u00edndice en la BD para este campo primary_key=False, # No es clave primaria db_column=\"product_name\", # Nombre de columna espec\u00edfico en la BD choices=( # Lista predefinida de opciones ('S', 'Small'), ('M', 'Medium'), ('L', 'Large'), ), validators=[MinLengthValidator(3)], # Lista de validadores error_messages={ # Mensajes de error personalizados 'null': 'Este campo no puede ser nulo', 'blank': 'Este campo es obligatorio', } )","title":"3. Opciones comunes para todos los campos"},{"location":"django/modelos/#4-relaciones-entre-modelos","text":"","title":"4. Relaciones entre modelos"},{"location":"django/modelos/#foreignkey-relacion-uno-a-muchos","text":"class Categoria(models.Model): nombre = models.CharField(max_length=100) def __str__(self): return self.nombre class Producto(models.Model): # Muchos productos pueden pertenecer a una categor\u00eda categoria = models.ForeignKey( Categoria, # Modelo relacionado on_delete=models.CASCADE, # Comportamiento al eliminar: CASCADE, PROTECT, SET_NULL, SET_DEFAULT, DO_NOTHING, SET() related_name='productos', # Nombre para la relaci\u00f3n inversa related_query_name='producto', # Nombre para filtros en consultas inversas limit_choices_to={'activa': True}, # Limita las opciones disponibles db_constraint=True, # Crea restricci\u00f3n en la BD to_field='id', # Campo al que se relaciona (por defecto es pk) swappable=True, # Si se puede intercambiar el modelo relacionado db_index=True, # Crea \u00edndice para este campo null=True, # Permite nulos blank=True # Permite vac\u00edos en formularios ) # Auto-referencia (un producto puede ser el repuesto de otro) repuesto_de = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True) # Referencias a modelos a\u00fan no definidos creado_por = models.ForeignKey('auth.User', on_delete=models.PROTECT)","title":"ForeignKey (Relaci\u00f3n uno a muchos)"},{"location":"django/modelos/#manytomanyfield-relacion-muchos-a-muchos","text":"class Etiqueta(models.Model): nombre = models.CharField(max_length=50) def __str__(self): return self.nombre class Producto(models.Model): # Un producto puede tener muchas etiquetas y una etiqueta puede estar en muchos productos etiquetas = models.ManyToManyField( Etiqueta, related_name='productos', blank=True, through='ProductoEtiqueta', # Modelo para la tabla intermedia personalizada through_fields=('producto', 'etiqueta'), # Campos para la relaci\u00f3n en el modelo through db_table='producto_etiqueta', # Nombre de la tabla intermedia en la BD symmetrical=False, # Para relaciones ManyToMany con 'self' ) # Auto-referencia (productos compatibles con este producto) compatible_con = models.ManyToManyField('self', blank=True, symmetrical=False) # Tabla intermedia personalizada para a\u00f1adir campos a la relaci\u00f3n class ProductoEtiqueta(models.Model): producto = models.ForeignKey(Producto, on_delete=models.CASCADE) etiqueta = models.ForeignKey(Etiqueta, on_delete=models.CASCADE) fecha_asignacion = models.DateTimeField(auto_now_add=True) asignado_por = models.ForeignKey('auth.User', on_delete=models.SET_NULL, null=True) class Meta: # Garantiza que no haya duplicados unique_together = [['producto', 'etiqueta']]","title":"ManyToManyField (Relaci\u00f3n muchos a muchos)"},{"location":"django/modelos/#onetoonefield-relacion-uno-a-uno","text":"class Empleado(models.Model): nombre = models.CharField(max_length=100) apellido = models.CharField(max_length=100) class Perfil(models.Model): # Un perfil pertenece a un solo empleado y un empleado tiene un solo perfil empleado = models.OneToOneField( Empleado, on_delete=models.CASCADE, primary_key=True, # Usa el mismo ID que el empleado parent_link=True, # Para herencia multi-tabla ) fecha_nacimiento = models.DateField(null=True, blank=True) foto = models.ImageField(upload_to='perfiles/', null=True, blank=True)","title":"OneToOneField (Relaci\u00f3n uno a uno)"},{"location":"django/modelos/#5-metodos-y-propiedades-personalizados","text":"from django.utils import timezone import datetime class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) costo = models.DecimalField(max_digits=10, decimal_places=2) stock = models.PositiveIntegerField(default=0) fecha_caducidad = models.DateField(null=True, blank=True) # Propiedad calculada @property def margen(self): \"\"\"Calcula el margen de beneficio\"\"\" if self.costo == 0: return 0 return ((self.precio - self.costo) / self.precio) * 100 # Propiedad con setter @property def precio_con_iva(self): \"\"\"Precio con IVA incluido\"\"\" return self.precio * 1.21 @precio_con_iva.setter def precio_con_iva(self, valor): \"\"\"Establece el precio sin IVA a partir del precio con IVA\"\"\" self.precio = valor / 1.21 # M\u00e9todo de instancia def esta_disponible(self): \"\"\"Determina si el producto est\u00e1 disponible\"\"\" if self.stock <= 0: return False if self.fecha_caducidad and self.fecha_caducidad <= timezone.now().date(): return False return True # M\u00e9todo con par\u00e1metros def aplicar_descuento(self, porcentaje): \"\"\"Aplica un descuento al precio del producto\"\"\" if porcentaje < 0 or porcentaje > 100: raise ValueError(\"El porcentaje debe estar entre 0 y 100\") self.precio = self.precio * (1 - (porcentaje / 100)) return self.precio # M\u00e9todo que modifica m\u00faltiples campos def recibir_stock(self, cantidad, nuevo_costo=None): \"\"\"A\u00f1ade stock y actualiza el costo si se proporciona\"\"\" if cantidad <= 0: raise ValueError(\"La cantidad debe ser positiva\") self.stock += cantidad if nuevo_costo is not None: self.costo = nuevo_costo self.save(update_fields=['stock', 'costo']) return self.stock # M\u00e9todo que interact\u00faa con otras instancias def transferir_stock(self, producto_destino, cantidad): \"\"\"Transfiere stock a otro producto\"\"\" if cantidad <= 0: raise ValueError(\"La cantidad debe ser positiva\") if cantidad > self.stock: raise ValueError(\"Stock insuficiente\") self.stock -= cantidad producto_destino.stock += cantidad self.save(update_fields=['stock']) producto_destino.save(update_fields=['stock']) # M\u00e9todo que devuelve un valor complejo o QuerySet def obtener_productos_similares(self): \"\"\"Encuentra productos con precios similares\"\"\" min_precio = self.precio * 0.9 max_precio = self.precio * 1.1 return Producto.objects.filter( precio__gte=min_precio, precio__lte=max_precio ).exclude(id=self.id)","title":"5. M\u00e9todos y propiedades personalizados"},{"location":"django/modelos/#6-metodos-estaticos-y-de-clase","text":"class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) # M\u00e9todo est\u00e1tico (no accede a la instancia ni a la clase) @staticmethod def convertir_moneda(precio, tasa_cambio): \"\"\"Convierte un precio a otra moneda usando la tasa de cambio\"\"\" return precio * tasa_cambio # M\u00e9todo de clase (accede a la clase pero no a la instancia) @classmethod def crear_oferta(cls, nombre, precio_original, descuento_porcentaje): \"\"\"Crea un nuevo producto con descuento aplicado\"\"\" precio_con_descuento = precio_original * (1 - (descuento_porcentaje / 100)) return cls.objects.create( nombre=f\"{nombre} (Oferta {descuento_porcentaje}%)\", precio=precio_con_descuento ) # M\u00e9todo de clase que devuelve un QuerySet @classmethod def obtener_productos_caros(cls): \"\"\"Obtiene productos con precio superior a la media\"\"\" from django.db.models import Avg precio_medio = cls.objects.aggregate(Avg('precio'))['precio__avg'] return cls.objects.filter(precio__gt=precio_medio)","title":"6. M\u00e9todos est\u00e1ticos y de clase"},{"location":"django/modelos/#7-sobreescritura-de-metodos-del-modelo","text":"class Producto(models.Model): nombre = models.CharField(max_length=100) slug = models.SlugField(unique=True) # Personalizar representaci\u00f3n en string def __str__(self): return f\"{self.nombre} ({self.id})\" # Personalizar representaci\u00f3n en depuraci\u00f3n def __repr__(self): return f\"<Producto: {self.id}, {self.nombre}>\" # Personalizar el comportamiento de guardado def save(self, *args, **kwargs): # Acciones antes de guardar if not self.slug: from django.utils.text import slugify self.slug = slugify(self.nombre) # Validaciones personalizadas if len(self.nombre) < 3: raise ValueError(\"El nombre debe tener al menos 3 caracteres\") # Llamar al m\u00e9todo original super().save(*args, **kwargs) # Acciones despu\u00e9s de guardar self.crear_thumbnail() # Personalizar el comportamiento de eliminaci\u00f3n def delete(self, *args, **kwargs): # Acciones antes de eliminar self.eliminar_archivos_asociados() # Llamar al m\u00e9todo original super().delete(*args, **kwargs) # Acciones despu\u00e9s de eliminar (cuidado: la instancia ya no existe en la BD) # Personalizar el comportamiento de validaci\u00f3n def clean(self): \"\"\"Validaciones a nivel de modelo (no de campo)\"\"\" from django.core.exceptions import ValidationError if self.precio < self.costo: raise ValidationError(\"El precio no puede ser menor que el costo\") if self.fecha_inicio and self.fecha_fin and self.fecha_inicio > self.fecha_fin: raise ValidationError({ 'fecha_inicio': \"La fecha de inicio no puede ser posterior a la fecha de fin\", 'fecha_fin': \"La fecha de fin no puede ser anterior a la fecha de inicio\" }) # Personalizar URLs def get_absolute_url(self): \"\"\"Devuelve la URL \u00fanica para este objeto\"\"\" from django.urls import reverse return reverse('producto-detalle', kwargs={'slug': self.slug})","title":"7. Sobreescritura de m\u00e9todos del modelo"},{"location":"django/modelos/#8-meta-opciones","text":"class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) class Meta: # Nombre y plurales para la interfaz de administraci\u00f3n verbose_name = \"Producto\" verbose_name_plural = \"Productos\" # Ordenaci\u00f3n por defecto ordering = ['-fecha_creacion', 'nombre'] # \u00cdndices para optimizar consultas indexes = [ models.Index(fields=['nombre']), models.Index(fields=['precio', 'categoria']), models.Index(fields=['-fecha_creacion'], name='idx_fecha_creacion_desc'), ] # Restricciones de unicidad compuesta unique_together = [['sku', 'tienda'], ['slug', 'categoria']] # Restricciones de unicidad con condiciones (Django 2.2+) constraints = [ models.UniqueConstraint( fields=['sku', 'tienda'], name='unique_sku_por_tienda' ), models.UniqueConstraint( fields=['slug'], condition=models.Q(activo=True), name='unique_slug_activos' ), models.CheckConstraint( check=models.Q(precio__gte=0), name='precio_positivo' ), ] # Nombrar la tabla en la base de datos db_table = 'inventario_producto' # Otras opciones Meta abstract = False # Si es True, ser\u00e1 un modelo abstracto app_label = 'inventario' # Especifica la app a la que pertenece db_tablespace = 'idx_tbls' # Espacio de tabla para \u00edndices default_permissions = ('add', 'change', 'delete', 'view') default_related_name = 'productos' # Nombre relacional por defecto get_latest_by = 'fecha_creacion' # Campo para latest() y earliest() managed = True # Si Django gestiona esta tabla order_with_respect_to = 'categoria' # Permite ordenar respecto a otro campo permissions = [ # Permisos adicionales ('puede_publicar', 'Puede publicar productos'), ('puede_destacar', 'Puede destacar productos'), ] proxy = False # Si es modelo proxy required_db_features = ['supports_json_field'] # Caracter\u00edsticas requeridas de la BD select_on_save = False # Si hacer SELECT antes de guardar","title":"8. Meta opciones"},{"location":"django/modelos/#9-managers-personalizados","text":"class ProductoActivoManager(models.Manager): \"\"\"Manager que solo devuelve productos activos\"\"\" def get_queryset(self): return super().get_queryset().filter(activo=True) # M\u00e9todo personalizado del manager def destacados(self): \"\"\"Devuelve productos activos y destacados\"\"\" return self.filter(destacado=True) # M\u00e9todo para crear objetos con valores por defecto def crear_producto_destacado(self, nombre, precio, **kwargs): return self.create( nombre=nombre, precio=precio, destacado=True, **kwargs ) class ProductoDesactivoManager(models.Manager): \"\"\"Manager que solo devuelve productos inactivos\"\"\" def get_queryset(self): return super().get_queryset().filter(activo=False) class ProductoQuerySet(models.QuerySet): \"\"\"QuerySet personalizado con m\u00e9todos adicionales\"\"\" def destacados(self): return self.filter(destacado=True) def por_precio(self, precio_min, precio_max): return self.filter(precio__gte=precio_min, precio__lte=precio_max) def agotados(self): return self.filter(stock=0) # M\u00e9todos que modifiquen datos en masa def destacar_todos(self): return self.update(destacado=True) def subir_precio(self, porcentaje): from django.db.models import F return self.update(precio=F('precio') * (1 + porcentaje/100)) class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) stock = models.PositiveIntegerField(default=0) activo = models.BooleanField(default=True) destacado = models.BooleanField(default=False) # Manager por defecto objects = models.Manager() # Managers adicionales activos = ProductoActivoManager() inactivos = ProductoDesactivoManager() # Manager personalizado que devuelve QuerySet personalizado todo = models.Manager.from_queryset(ProductoQuerySet)() def __str__(self): return self.nombre Ahora podemos usar: # Usando los diferentes managers Producto.objects.all() # Todos los productos Producto.activos.all() # Solo productos activos Producto.inactivos.all() # Solo productos inactivos Producto.activos.destacados() # Productos activos y destacados # Usando el QuerySet personalizado Producto.todo.destacados() Producto.todo.por_precio(10, 100) Producto.todo.agotados() # Operaciones en masa Producto.todo.filter(categoria=5).destacar_todos() Producto.todo.filter(marca=\"Sony\").subir_precio(5)","title":"9. Managers personalizados"},{"location":"django/modelos/#10-herencia-de-modelos","text":"","title":"10. Herencia de modelos"},{"location":"django/modelos/#herencia-abstracta","text":"class ModeloBase(models.Model): \"\"\"Modelo abstracto con campos comunes\"\"\" creado = models.DateTimeField(auto_now_add=True) modificado = models.DateTimeField(auto_now=True) activo = models.BooleanField(default=True) class Meta: abstract = True # No crea tabla para este modelo def activar(self): self.activo = True self.save(update_fields=['activo']) def desactivar(self): self.activo = False self.save(update_fields=['activo']) class Producto(ModeloBase): \"\"\"Hereda todos los campos y m\u00e9todos de ModeloBase\"\"\" nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) # Puede a\u00f1adir sus propias Meta opciones class Meta(ModeloBase.Meta): verbose_name = \"Producto\" ordering = ['-creado'] class Cliente(ModeloBase): \"\"\"Tambi\u00e9n hereda de ModeloBase\"\"\" nombre = models.CharField(max_length=100) email = models.EmailField()","title":"Herencia abstracta"},{"location":"django/modelos/#herencia-multi-tabla","text":"class Producto(models.Model): \"\"\"Modelo base para todos los productos\"\"\" nombre = models.CharField(max_length=100) descripcion = models.TextField(blank=True) precio = models.DecimalField(max_digits=10, decimal_places=2) def __str__(self): return self.nombre class Libro(Producto): \"\"\"Crea una tabla separada con un OneToOneField a Producto\"\"\" autor = models.CharField(max_length=100) isbn = models.CharField(max_length=13) paginas = models.PositiveIntegerField() def __str__(self): return f\"{self.nombre} de {self.autor}\" class Electronico(Producto): \"\"\"Otra tabla separada con relaci\u00f3n a Producto\"\"\" marca = models.CharField(max_length=50) modelo = models.CharField(max_length=50) garantia_meses = models.PositiveIntegerField() def __str__(self): return f\"{self.marca} {self.modelo}\"","title":"Herencia multi-tabla"},{"location":"django/modelos/#herencia-proxy","text":"class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) tipo = models.CharField(max_length=20, choices=[ ('normal', 'Normal'), ('destacado', 'Destacado'), ('oferta', 'Oferta') ]) def __str__(self): return self.nombre class ProductoDestacado(Producto): \"\"\" Modelo proxy que no crea nueva tabla, sino que proporciona una vista diferente del modelo Producto \"\"\" objects = models.Manager() # Manager por defecto class Meta: proxy = True # Es un modelo proxy ordering = ['-precio'] # Ordenaci\u00f3n diferente def destacar(self): self.tipo = 'destacado' self.save() @property def precio_original(self): \"\"\"Calcula el precio original antes del descuento\"\"\" return self.precio * 1.2","title":"Herencia proxy"},{"location":"django/modelos/#11-senales-signals","text":"# En models.py o en signals.py from django.db.models.signals import pre_save, post_save, pre_delete, post_delete from django.dispatch import receiver from .models import Producto @receiver(pre_save, sender=Producto) def producto_pre_save(sender, instance, **kwargs): \"\"\"Se ejecuta antes de guardar un producto\"\"\" # Podemos modificar la instancia antes de guardarla if instance.stock < 0: instance.stock = 0 # Calcular campos derivados if instance.precio and instance.costo: instance.margen = instance.precio - instance.costo @receiver(post_save, sender=Producto) def producto_post_save(sender, instance, created, **kwargs): \"\"\"Se ejecuta despu\u00e9s de guardar un producto\"\"\" if created: # Solo si es un producto nuevo from .tasks import notificar_nuevo_producto notificar_nuevo_producto.delay(instance.id) else: # Si es una actualizaci\u00f3n if 'precio' in kwargs.get('update_fields', []): from .tasks import actualizar_precios_relacionados actualizar_precios_relacionados.delay(instance.id) @receiver(pre_delete, sender=Producto) def producto_pre_delete(sender, instance, **kwargs): \"\"\"Se ejecuta antes de eliminar un producto\"\"\" # Guardar registro de eliminaci\u00f3n from .models import RegistroEliminacion RegistroEliminacion.objects.create( modelo='Producto', objeto_id=instance.id, nombre=instance.nombre, datos=str(instance.__dict__) ) # Eliminar archivos asociados if instance.imagen: import os if os.path.isfile(instance.imagen.path): os.remove(instance.imagen.path) @receiver(post_delete, sender=Producto) def producto_post_delete(sender, instance, **kwargs): \"\"\"Se ejecuta despu\u00e9s de eliminar un producto\"\"\" # Actualizar cach\u00e9 o b\u00fasqueda from .tasks import actualizar_cache_productos actualizar_cache_productos.delay() # Se\u00f1ales personalizadas from django.dispatch import Signal # Definir una se\u00f1al personalizada producto_agotado = Signal() # Puede incluir providing_args=['producto'] class Venta(models.Model): producto = models.ForeignKey(Producto, on_delete=models.CASCADE) cantidad = models.PositiveIntegerField() def save(self, *args, **kwargs): super().save(*args, **kwargs) # Actualizar stock self.producto.stock -= self.cantidad self.producto.save(update_fields=['stock']) # Emitir se\u00f1al si el producto se agot\u00f3 if self.producto.stock == 0: producto_agotado.send(sender=self.__class__, producto=self.producto) # En otro lugar, escuchar la se\u00f1al personalizada @receiver(producto_agotado) def notificar_producto_agotado(sender, producto, **kwargs): from django.core.mail import send_mail send_mail( f'Producto agotado: {producto.nombre}', f'El producto {producto.nombre} se ha agotado.', 'sistema@ejemplo.com', ['almacen@ejemplo.com'], )","title":"11. Se\u00f1ales (Signals)"},{"location":"django/modelos/#12-campos-personalizados","text":"from django.db import models from django.core.exceptions import ValidationError def validar_rango(value): if value < 0 or value > 100: raise ValidationError('El valor debe estar entre 0 y 100') class RangoEnteroField(models.IntegerField): \"\"\"Campo entero con validaci\u00f3n de rango personalizada\"\"\" def __init__(self, min_value=None, max_value=None, *args, **kwargs): self.min_value = min_value self.max_value = max_value super().__init__(*args, **kwargs) def formfield(self, **kwargs): # Personaliza el campo de formulario defaults = { 'min_value': self.min_value, 'max_value': self.max_value, } defaults.update(kwargs) return super().formfield(**defaults) def deconstruct(self): # Necesario para las migraciones name, path, args, kwargs = super().deconstruct() if self.min_value is not None: kwargs['min_value'] = self.min_value if self.max_value is not None: kwargs['max_value'] = self.max_value return name, path, args, kwargs def validate(self, value, model_instance): # Validaci\u00f3n personalizada super().validate(value, model_instance) if self.min_value is not None and value < self.min_value: raise ValidationError(f'El valor debe ser mayor o igual a {self.min_value}') if self.max_value is not None and value > self.max_value: raise ValidationError(f'El valor debe ser menor o igual a {self.max_value}') class ColorField(models.CharField): \"\"\"Campo para almacenar colores en formato hexadecimal\"\"\" def __init__(self, *args, **kwargs): kwargs['max_length'] = 7 super().__init__(*args, **kwargs) def clean(self, value, model_instance): value = super().clean(value, model_instance) if value and not value.startswith('#'): value = f'#{value}' return value def validate(self, value, model_instance): super().validate(value, model_instance) if value: import re if not re.match(r'^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$', value): raise ValidationError('Formato de color hexadecimal inv\u00e1lido') class Producto(models.Model): nombre = models.CharField(max_length=100) calificacion = RangoEnteroField(min_value=1, max_value=5, help_text=\"Calificaci\u00f3n de 1 a 5 estrellas\") color_principal = ColorField(null=True, blank=True, help_text=\"Color en formato hexadecimal (#RRGGBB)\")","title":"12. Campos personalizados"},{"location":"django/modelos/#13-operaciones-avanzadas-con-querysets","text":"from django.db.models import F, Q, Count, Sum, Avg, Min, Max, Case, When, Value, IntegerField, CharField from django.db.models.functions import ExtractYear, ExtractMonth, Concat class Producto(models.Model): nombre = models.CharField(max_length=100) precio = models.DecimalField(max_digits=10, decimal_places=2) stock = models.PositiveIntegerField(default=0) categoria = models.ForeignKey('Categoria', on_delete=models.CASCADE) fecha_creacion = models.DateTimeField(auto_now_add=True) @classmethod def consultas_avanzadas(cls): # Ejemplos de consultas avanzadas # F expressions - Operaciones a nivel de base de datos cls.objects.update(precio=F('precio') * 1.1) # Aumenta todos los precios un 10% # Productos cuyo precio es mayor que el precio base productos_caros = cls.objects.filter(precio__gt=F('precio_base')) # Productos con m\u00e1s ventas que stock productos_exitosos = cls.objects.filter(ventas_totales__gt=F('stock')) # Q expressions - Consultas complejas con OR, AND, NOT from django.db.models import Q # Productos baratos O con stock alto productos = cls.objects.filter( Q(precio__lt=10) | Q(stock__gt=100) ) # Productos caros Y de categor\u00eda espec\u00edfica, excluyendo una marca productos = cls.objects.filter( Q(precio__gt=50) & Q(categoria__nombre='Electr\u00f3nica') & ~Q(marca='Marca Gen\u00e9rica') ) # Funciones de agregaci\u00f3n from django.db.models import Avg, Count, Min, Max, Sum # Estad\u00edsticas generales stats = cls.objects.aggregate( total_productos=Count('id'), precio_promedio=Avg('precio'), precio_minimo=Min('precio'), precio_maximo=Max('precio'), valor_inventario=Sum(F('precio') * F('stock')) ) # Anotaciones - A\u00f1adir campos calculados a cada objeto productos = cls.objects.annotate( valor_total=F('precio') * F('stock'), descuento=F('precio_base') - F('precio'), porcentaje_descuento=(F('precio_base') - F('precio')) * 100 / F('precio_base') ) # Anotaciones con Count productos = cls.objects.annotate( num_reviews=Count('review'), num_ventas=Count('venta') ) # Anotaciones con Case/When (if/else condicionales) from django.db.models import Case, When, Value, IntegerField productos = cls.objects.annotate( estado_stock=Case( When(stock=0, then=Value('Agotado')), When(stock__lt=10, then=Value('Bajo')), When(stock__lt=50, then=Value('Medio')), default=Value('Alto'), output_field=CharField() ) ) # Agrupaci\u00f3n (GROUP BY) from django.db.models.functions import ExtractYear, ExtractMonth # Ventas por a\u00f1o y mes ventas_por_mes = cls.objects.annotate( a\u00f1o=ExtractYear('fecha_venta'), mes=ExtractMonth('fecha_venta') ).values('a\u00f1o', 'mes').annotate( total_ventas=Sum('cantidad'), ingresos=Sum(F('cantidad') * F('precio_unitario')) ).order_by('a\u00f1o', 'mes') # Concatenaci\u00f3n de campos from django.db.models.functions import Concat from django.db.models import Value productos = cls.objects.annotate( nombre_completo=Concat( 'nombre', Value(' - '), 'marca', Value(' ('), 'categoria__nombre', Value(')') ) ) return \"Ejemplos de consultas avanzadas de QuerySets\"","title":"13. Operaciones avanzadas con QuerySets"},{"location":"django/modelos/#14-consultas-y-joins-complejos","text":"class Producto(models.Model): nombre = models.CharField(max_length=100) categoria = models.ForeignKey('Categoria', on_delete=models.CASCADE) @classmethod def consultas_complejas(cls): # select_related - Para relaciones ForeignKey y OneToOne productos = cls.objects.select_related('categoria', 'marca') # Ahora podemos acceder a producto.categoria.nombre sin consultas adicionales for producto in productos: print(f\"{producto.nombre} - {producto.categoria.nombre}\") # prefetch_related - Para relaciones ManyToMany y \"relaciones inversas\" productos = cls.objects.prefetch_related('etiquetas', 'reviews') # Prefetch con Prefetch - Para personalizar la consulta prefetch from django.db.models import Prefetch productos = cls.objects.prefetch_related( Prefetch( 'reviews', queryset=Review.objects.filter(rating__gte=4).select_related('usuario'), to_attr='buenas_reviews' ) ) # Consultas complejas con select_related + prefetch_related productos = cls.objects.select_related( 'categoria', 'marca' ).prefetch_related( 'etiquetas', Prefetch('reviews', queryset=Review.objects.select_related('usuario')) ) # Consultas con joins expl\u00edcitos from django.db.models import OuterRef, Subquery # Subconsulta - \u00daltima review de cada producto ultima_review = Review.objects.filter( producto=OuterRef('pk') ).order_by('-fecha_creacion').values('texto')[:1] productos = cls.objects.annotate( ultima_review=Subquery(ultima_review) ) # Consultas en bruto (raw SQL) productos = cls.objects.raw(\"\"\" SELECT p.*, c.nombre as categoria_nombre FROM producto p JOIN categoria c ON p.categoria_id = c.id WHERE p.precio > 100 ORDER BY p.nombre \"\"\") # Usando extra() para a\u00f1adir JOIN, WHERE o SELECT productos = cls.objects.extra( select={'categoria_nombre': 'categoria.nombre'}, tables=['categoria'], where=['producto.categoria_id = categoria.id', 'producto.precio > 100'] ) return \"Ejemplos de consultas y joins complejos\"","title":"14. Consultas y joins complejos"},{"location":"django/modelos/#15-transacciones-y-operaciones-atomicas","text":"from django.db import transaction class Venta(models.Model): producto = models.ForeignKey('Producto', on_delete=models.CASCADE) cantidad = models.PositiveIntegerField() @classmethod def realizar_venta(cls, producto_id, cantidad, cliente_id): # Transacci\u00f3n at\u00f3mica decorando funci\u00f3n @transaction.atomic def _realizar_venta(): # Todo esto ocurre dentro de una transacci\u00f3n producto = Producto.objects.select_for_update().get(id=producto_id) if producto.stock < cantidad: raise ValueError(\"Stock insuficiente\") # Actualizar stock producto.stock -= cantidad producto.save(update_fields=['stock']) # Crear venta venta = cls.objects.create( producto=producto, cantidad=cantidad, cliente_id=cliente_id ) # Actualizar estad\u00edsticas ProductoEstadistica.objects.update_or_create( producto=producto, defaults={'total_vendido': F('total_vendido') + cantidad} ) return venta return _realizar_venta() @classmethod def otro_ejemplo_transacciones(cls): # Usando with para bloques de transacci\u00f3n try: with transaction.atomic(): # Todo dentro de este bloque es parte de la misma transacci\u00f3n producto1 = Producto.objects.select_for_update().get(id=1) producto1.stock -= 1 producto1.save() producto2 = Producto.objects.select_for_update().get(id=2) producto2.stock -= 1 if producto2.stock < 0: # Si hay un error, toda la transacci\u00f3n se deshace raise ValueError(\"Stock insuficiente para producto 2\") producto2.save() except Exception as e: # La transacci\u00f3n se ha deshecho, ning\u00fan cambio se guard\u00f3 return f\"Error en la transacci\u00f3n: {str(e)}\" # Puntos de guardado (savepoints) with transaction.atomic(): # Punto de guardado 1 sid1 = transaction.savepoint() producto1 = Producto.objects.get(id=1) producto1.stock -= 1 producto1.save() if alguna_condicion: # Deshacer hasta el punto de guardado 1 transaction.savepoint_rollback(sid1) else: # Confirmar el punto de guardado 1 transaction.savepoint_commit(sid1) # Punto de guardado 2 sid2 = transaction.savepoint() try: producto2 = Producto.objects.get(id=2) producto2.stock -= 1 producto2.save() except: # Deshacer hasta el punto de guardado 2 transaction.savepoint_rollback(sid2) return \"Ejemplos de transacciones\"","title":"15. Transacciones y operaciones at\u00f3micas"},{"location":"django/modelos/#16-indices-constraints-y-referencias-complejas","text":"class Categoria(models.Model): nombre = models.CharField(max_length=100) class Meta: verbose_name_plural = \"Categor\u00edas\" class Producto(models.Model): nombre = models.CharField(max_length=100) sku = models.CharField(max_length=20) precio = models.DecimalField(max_digits=10, decimal_places=2) categoria = models.ForeignKey( Categoria, on_delete=models.PROTECT, # No permite eliminar categor\u00edas con productos related_name='productos' ) proveedor = models.ForeignKey( 'Proveedor', on_delete=models.SET_NULL, # Permite eliminar proveedores, poniendo NULL null=True, blank=True ) productos_relacionados = models.ManyToManyField( 'self', # Relaci\u00f3n a s\u00ed mismo symmetrical=False, # A->B no implica B->A blank=True ) # \u00cdndices simples y compuestos (Django 2.2+) class Meta: indexes = [ models.Index(fields=['nombre']), models.Index(fields=['categoria', 'precio']), models.Index(fields=['sku'], name='idx_producto_sku'), # \u00cdndice parcial solo para productos activos models.Index( fields=['nombre'], name='idx_producto_activo_nombre', condition=models.Q(activo=True) ), # \u00cdndice para b\u00fasqueda de texto models.Index( name='idx_producto_busqueda', fields=['nombre', 'descripcion'], opclasses=['varchar_pattern_ops', 'text_pattern_ops'] ), ] # Constraints complejas (Django 2.2+) constraints = [ # Restricci\u00f3n de unicidad models.UniqueConstraint( fields=['sku', 'proveedor'], name='uq_producto_sku_proveedor' ), # Restricci\u00f3n de unicidad condicional models.UniqueConstraint( fields=['slug'], condition=models.Q(activo=True), name='uq_producto_activo_slug' ), # Restricci\u00f3n CHECK models.CheckConstraint( check=models.Q(precio__gt=0), name='chk_producto_precio_positivo' ), models.CheckConstraint( check=models.Q(fecha_fin__gt=models.F('fecha_inicio')), name='chk_producto_fechas_validas' ), ]","title":"16. \u00cdndices, Constraints y Referencias complejas"},{"location":"django/modelos/#17-funciones-de-busqueda-y-expresiones-avanzadas","text":"from django.db.models import F, Func, Value from django.db.models.functions import Concat, Lower, Upper, Substr, Length, Replace, ExtractYear, Cast from django.db.models import CharField, IntegerField, DateField class Producto(models.Model): nombre = models.CharField(max_length=100) descripcion = models.TextField() precio = models.DecimalField(max_digits=10, decimal_places=2) fecha_creacion = models.DateTimeField(auto_now_add=True) @classmethod def funciones_avanzadas(cls): # Operaciones con texto productos = cls.objects.annotate( # Concatenaci\u00f3n titulo_completo=Concat( 'nombre', Value(' - '), 'categoria__nombre', output_field=CharField() ), # Min\u00fasculas y may\u00fasculas nombre_lower=Lower('nombre'), nombre_upper=Upper('nombre'), # Subcadenas primera_letra=Substr('nombre', 1, 1), # Longitud longitud_nombre=Length('nombre'), # Reemplazo sin_espacios=Replace('nombre', Value(' '), Value('_')) ) # Operaciones con fecha productos = cls.objects.annotate( # Extraer componentes de fecha a\u00f1o=ExtractYear('fecha_creacion'), mes=ExtractMonth('fecha_creacion'), # Diferencia entre fechas dias_activo=Cast( Now() - F('fecha_creacion'), output_field=DurationField() ) ) # Funciones matem\u00e1ticas from django.db.models.functions import Abs, Ceil, Floor, Round, Sin, Cos, Sqrt, Power productos = cls.objects.annotate( precio_redondeado=Round('precio'), precio_techo=Ceil('precio'), precio_suelo=Floor('precio'), precio_absoluto=Abs('precio'), precio_raiz=Sqrt('precio'), precio_cuadrado=Power('precio', 2) ) # Creando funciones personalizadas class GroupConcat(Func): function = 'GROUP_CONCAT' template = '%(function)s(%(expressions)s)' # Usando funciones SQL directamente from django.db.models.expressions import RawSQL productos = cls.objects.annotate( distancia=RawSQL( \"ST_Distance(ubicacion, ST_SetSRID(ST_MakePoint(%s, %s), 4326))\", (longitude, latitude) ) ).order_by('distancia') return \"Ejemplos de expresiones y funciones avanzadas\"","title":"17. Funciones de B\u00fasqueda y Expresiones Avanzadas"},{"location":"django/modelos/#18-opciones-de-definicion-de-modelos-menos-comunes","text":"class ProductoPersonalizado(models.Model): # Campo proxy que apunta a otro modelo pero con un nombre diferente categoria = models.ForeignKey( 'Categoria', on_delete=models.CASCADE, db_column='categoria_id', # Nombre de columna en la BD to_field='codigo_categoria', # Campo en Categoria (no es la PK) related_name='mis_productos', # Nombre de la relaci\u00f3n inversa related_query_name='mi_producto', # Nombre para filtros inversos limit_choices_to={'activa': True}, # Limita las opciones disponibles swappable=True, # Si el modelo relacionado es intercambiable ) # Definir un Manager de forma expl\u00edcita con una funci\u00f3n def productos_activos(): return models.Manager().from_queryset( lambda self: self.filter(activo=True) )() activos = productos_activos() # Opciones menos comunes para campos codigo_promocional = models.CharField( max_length=10, db_collation='utf8_bin', # Collation espec\u00edfica (sensible a may\u00fasculas/min\u00fasculas) db_index=True, # \u00cdndice en la BD para este campo ) # Campo con restricciones de BD pero sin restricciones en Python codigo_interno = models.CharField( max_length=50, db_column='internal_code', # Nombre en la BD error_messages={ # Mensajes de error personalizados 'blank': 'Este campo no puede estar vac\u00edo.', 'unique': 'Ya existe un producto con este c\u00f3digo interno.' } ) # Definir una PK personalizada codigo_unico = models.CharField( max_length=20, primary_key=True, # Este campo es la PK editable=False, # No se puede editar desde el admin ) class Meta: # Definir permisos a nivel de modelo default_permissions = ('add', 'change', 'delete', 'view') permissions = [ ('puede_publicar', 'Puede publicar productos'), ('puede_comprar', 'Puede comprar productos'), ] # Definir \u00edndice funcional indexes = [ models.Index( Lower('nombre'), name='idx_lower_nombre' ) ] # Controlar si Django maneja las tablas managed = True # Django gestiona esta tabla # Definir vistas de base de datos managed = False # Para usar con vistas de BD db_table = 'productos_activos_view' # Vista definida en la BD","title":"18. Opciones de Definici\u00f3n de Modelos menos comunes"},{"location":"django/modelos/#19-integracion-con-otros-sistemas-y-orm-avanzado","text":"# Integraci\u00f3n con PostgreSQL - Campos espec\u00edficos from django.contrib.postgres.fields import ArrayField, HStoreField, JSONField from django.contrib.postgres.search import SearchVectorField, SearchVector, SearchQuery, SearchRank from django.contrib.postgres.indexes import GinIndex class ProductoPostgreSQL(models.Model): nombre = models.CharField(max_length=100) tags = ArrayField( models.CharField(max_length=50), size=10, # Limita a 10 elementos blank=True, # Permite array vac\u00edo default=list # Valor por defecto ) atributos = HStoreField(default=dict) # Diccionario clave-valor metadatos = JSONField(default=dict) # Campo JSON # Para b\u00fasqueda de texto completo search_vector = SearchVectorField(null=True) class Meta: indexes = [ GinIndex(fields=['search_vector']) # \u00cdndice GIN para b\u00fasqueda r\u00e1pida ] def save(self, *args, **kwargs): # Actualiza el vector de b\u00fasqueda al guardar self.search_vector = ( SearchVector('nombre', weight='A') + SearchVector('descripcion', weight='B') ) super().save(*args, **kwargs) @classmethod def buscar(cls, consulta): search_query = SearchQuery(consulta) return cls.objects.annotate( rank=SearchRank(F('search_vector'), search_query) ).filter( search_vector=search_query ).order_by('-rank') @classmethod def consultas_especiales_postgres(cls): # Consulta en array (contiene elementos) productos = cls.objects.filter(tags__contains=['oferta', 'nuevo']) # Consulta en json/hstore productos = cls.objects.filter(metadatos__contains={'color': 'rojo'}) productos = cls.objects.filter(metadatos__color='rojo') # Conteo de elementos array from django.contrib.postgres.aggregates import ArrayLength productos = cls.objects.annotate( num_tags=ArrayLength('tags', 1) # 1 indica dimensi\u00f3n del array ).filter(num_tags__gt=3) return \"Consultas especiales PostgreSQL\" # Modelos no mapeados directamente a tablas class VentasReporte(models.Model): \"\"\"Modelo para manejar reportes complejos sin tabla directa\"\"\" class Meta: managed = False # No crea tabla @classmethod def ventas_por_mes(cls, a\u00f1o): \"\"\"Obtiene datos que no corresponden a un solo modelo\"\"\" return Venta.objects.filter( fecha__year=a\u00f1o ).annotate( mes=ExtractMonth('fecha') ).values('mes').annotate( total=Sum('total') ).order_by('mes')","title":"19. Integraci\u00f3n con otros sistemas y ORM avanzado"},{"location":"paquetes/extensiones/","text":"Paquetes que te recomiendo cuando trabajes con Django 1. Bootstrap Ideal para cuando el frontend debe salir rapido, Documentacion oficial . Comando de instalacion: pip install django-bootstrap5 Configuracion en el settings.py: INSTALLED_APPS = [ ... # terceros \"django_bootstrap5\", # agregar esta linea ] Preparar la carpeta de templates para que funcione tambien fuera de las apps que hagas en django: TEMPLATES = [ { \"BACKEND\": \"django.template.backends.django.DjangoTemplates\", \"DIRS\": [ BASE_DIR / \"templates\", # agregar esta linea ], \"APP_DIRS\": True, \"OPTIONS\": { \"context_processors\": [ \"django.template.context_processors.request\", \"django.contrib.auth.context_processors.auth\", \"django.contrib.messages.context_processors.messages\", ], }, }, ] Crear la plantilla base: <!DOCTYPE html> <html lang=\"en\"> <head> {% load django_bootstrap5 %} <!-- Agregar estas lineas al template de base para tener estilos y funcionalidad de js --> {% bootstrap_css %} {% bootstrap_javascript %} <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> <title> {% block title %} Django Project {% endblock %} </title> </head> <body> <div class=\"container-fluid\"> {% bootstrap_messages %} <!-- Esto se integra genial con la API de mensajes de django --> {% block content %} <!-- row - col - card --> {% endblock %} </div> </body> </html> 2. Python Dot Env Este paquete es muy importate para usar archivos .env y no exponer credenciales importantes, Pagina de pypi . Comando de instalacion: pip install python-dotenv Ahora creamos nuestro archivo .env a nivel del proyecto Ahora agreamos el siguiente codigo en el settings.py casi al inicio del archivo from pathlib import Path import os # agregamos esta linea from dotenv import load_dotenv # este el paquete que acabamos de instalar load_dotenv() # Cargar variables de entorno desde un archivo .env si existe ... DEBUG = os.getenv(\"DJANGO_DEBUG\") # accedemos a la variable de entorno definida en .env 3. Django HTMX HTMX es una libreria que permite hacer aplicaciones web mas dinamicas sin necesidad de usar tanto javascript, Documentacion oficial . Comando de instalacion: pip install django-htmx Ahora tenemos que poner esta app en las apps instaladas de django: INSTALLED_APPS = [ #... \"django_htmx\", ] y finalmente agregamos el middleware: MIDDLEWARE = [ #... \"django_htmx.middleware.HtmxMiddleware\", ]","title":"Extensiones Esenciales"},{"location":"paquetes/extensiones/#paquetes-que-te-recomiendo-cuando-trabajes-con-django","text":"","title":"Paquetes que te recomiendo cuando trabajes con Django"},{"location":"paquetes/extensiones/#1-bootstrap","text":"Ideal para cuando el frontend debe salir rapido, Documentacion oficial . Comando de instalacion: pip install django-bootstrap5 Configuracion en el settings.py: INSTALLED_APPS = [ ... # terceros \"django_bootstrap5\", # agregar esta linea ] Preparar la carpeta de templates para que funcione tambien fuera de las apps que hagas en django: TEMPLATES = [ { \"BACKEND\": \"django.template.backends.django.DjangoTemplates\", \"DIRS\": [ BASE_DIR / \"templates\", # agregar esta linea ], \"APP_DIRS\": True, \"OPTIONS\": { \"context_processors\": [ \"django.template.context_processors.request\", \"django.contrib.auth.context_processors.auth\", \"django.contrib.messages.context_processors.messages\", ], }, }, ] Crear la plantilla base: <!DOCTYPE html> <html lang=\"en\"> <head> {% load django_bootstrap5 %} <!-- Agregar estas lineas al template de base para tener estilos y funcionalidad de js --> {% bootstrap_css %} {% bootstrap_javascript %} <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> <title> {% block title %} Django Project {% endblock %} </title> </head> <body> <div class=\"container-fluid\"> {% bootstrap_messages %} <!-- Esto se integra genial con la API de mensajes de django --> {% block content %} <!-- row - col - card --> {% endblock %} </div> </body> </html>","title":"1. Bootstrap"},{"location":"paquetes/extensiones/#2-python-dot-env","text":"Este paquete es muy importate para usar archivos .env y no exponer credenciales importantes, Pagina de pypi . Comando de instalacion: pip install python-dotenv Ahora creamos nuestro archivo .env a nivel del proyecto Ahora agreamos el siguiente codigo en el settings.py casi al inicio del archivo from pathlib import Path import os # agregamos esta linea from dotenv import load_dotenv # este el paquete que acabamos de instalar load_dotenv() # Cargar variables de entorno desde un archivo .env si existe ... DEBUG = os.getenv(\"DJANGO_DEBUG\") # accedemos a la variable de entorno definida en .env","title":"2. Python Dot Env"},{"location":"paquetes/extensiones/#3-django-htmx","text":"HTMX es una libreria que permite hacer aplicaciones web mas dinamicas sin necesidad de usar tanto javascript, Documentacion oficial . Comando de instalacion: pip install django-htmx Ahora tenemos que poner esta app en las apps instaladas de django: INSTALLED_APPS = [ #... \"django_htmx\", ] y finalmente agregamos el middleware: MIDDLEWARE = [ #... \"django_htmx.middleware.HtmxMiddleware\", ]","title":"3. Django HTMX"},{"location":"primeros-pasos/configuracion-inicial/","text":"Primeros pasos por el settings.py Cambiar la internacionalizacion por la necesaria en el proyecto LANGUAGE_CODE = \"es-mx\" TIME_ZONE = \"America/Mexico_City\" USE_I18N = True USE_TZ = True Configurar los archivos estaticos y media # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/6.0/howto/static-files/ STATIC_URL = \"static/\" # Carpeta donde se recolectar\u00e1n en producci\u00f3n STATIC_ROOT = BASE_DIR / 'staticfiles' # media_url y media_root para archivos subidos por usuarios (im\u00e1genes, documentos) MEDIA_URL = '/media/' MEDIA_ROOT = BASE_DIR / 'media' # Carpeta donde se guardar\u00e1n los archivos subidos seguido a ese, se deben configurar las URL para poder servir los archivos en moodo desarrollo from django.contrib import admin from django.urls import path from django.conf import settings # importar settings from django.conf.urls.static import static # importar static urlpatterns = [ path(\"admin/\", admin.site.urls), ] if settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)","title":"Configuraci\u00f3n Inicial"},{"location":"primeros-pasos/configuracion-inicial/#primeros-pasos-por-el-settingspy","text":"","title":"Primeros pasos por el settings.py"},{"location":"primeros-pasos/configuracion-inicial/#cambiar-la-internacionalizacion-por-la-necesaria-en-el-proyecto","text":"LANGUAGE_CODE = \"es-mx\" TIME_ZONE = \"America/Mexico_City\" USE_I18N = True USE_TZ = True","title":"Cambiar la internacionalizacion por la necesaria en el proyecto"},{"location":"primeros-pasos/configuracion-inicial/#configurar-los-archivos-estaticos-y-media","text":"# Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/6.0/howto/static-files/ STATIC_URL = \"static/\" # Carpeta donde se recolectar\u00e1n en producci\u00f3n STATIC_ROOT = BASE_DIR / 'staticfiles' # media_url y media_root para archivos subidos por usuarios (im\u00e1genes, documentos) MEDIA_URL = '/media/' MEDIA_ROOT = BASE_DIR / 'media' # Carpeta donde se guardar\u00e1n los archivos subidos seguido a ese, se deben configurar las URL para poder servir los archivos en moodo desarrollo from django.contrib import admin from django.urls import path from django.conf import settings # importar settings from django.conf.urls.static import static # importar static urlpatterns = [ path(\"admin/\", admin.site.urls), ] if settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)","title":"Configurar los archivos estaticos y media"},{"location":"primeros-pasos/usuarios-autenticacion-perfiles/","text":"Modificacion del modelo de usuario tradicional 1. Modelo de auditorias A mi me gusta crear una app en django que se llame core , la cual, como su nombre lo dice, sera la app que utilizare para todo el nucleo de mi sistema y para iniciar me gusta siempre crear dos cosas: Un modelo que me sirva para ampliar los campos del modelo UserModel de django. Un modelo abstracto que tenga campos de auditoria, estos campos ya seran a necesidad de tu sistema pero yo siempre pongo campos como: Fecha de creacion, Fecha de modificacion, Usuario creacion, Usuario Modificacion y un campo que muestre si el registro esta activo o no (util para hacer soft delete y no perder registros en la base de datos) Entonces, como primer paso sera crear el Modelo que nos ayudara a extender el modelo de usuario que viene por defecto en django, para lograrlo haremos uso del paquete: from django.contrib.auth.models import AbstractUser y creamos nuestro modelo extendiendo de ese paquete: class UserModel(AbstractUser): pass Para este punto es recomendable que sepas utilizar el ORM de django, los metodos de las clases en python y el como funcionan los modelos en django. Ahora que ya tenemos nuestro modelo de usuario personalizado, podemos crear nuestro modelo abstracto de auditorias. Los modelos abstractos de django son una forma de decir que vamos a: crear una clase padre que contenga X campos la cual nos ayudara a que futuros modelos puedan heredar de esas clase (POO tradicional) sin que django cree la tabla abstracta en la base de datos. Para lograrlo, haremos uso de la clase Meta con la propiedad abstract = True: class AuditModel(models.Model): # Fecha created_at = models.DateTimeField(auto_now_add=True) updated_at = models.DateTimeField(auto_now=True) # Usuario created_by = models.ForeignKey( UserModel, on_delete=models.SET_NULL, null=True, blank=True, related_name='created_%(class)s_set' ) updated_by = models.ForeignKey( UserModel, on_delete=models.SET_NULL, null=True, blank=True, related_name='updated_%(class)s_set' ) active = models.BooleanField( default=True, help_text=\"Indica si el registro est\u00e1 activo.\", db_index=True, verbose_name=\"Activo\") class Meta: abstract = True Nota: El uso de %(class)s en el related_name permite que Django reemplace autom\u00e1ticamente este marcador con el nombre del modelo hijo que hereda de AuditModel , evitando as\u00ed conflictos de nombres en las relaciones inversas. Ahora solo debemos decirle a django que hemos cambiar su modelo usuario , lo cual se realiza agregando las siguientes lineas en el archivo settings.py AUTH_USER_MODEL = 'core.UserModel' Y finalmente estamos listos para hacer el makemigrations y migrate python manage.py makemigrations python manage.py migrate 2. Login de Usuarios (Nivel Basico) Django ya viene cargado con librerias, que nos ayudan ha controlar todo el proceso de autenticacion de un usuario, estos procesos yo los seguire incluyendo en la app de core , quiere decir que tanto Vistas Modelos Templates Signals URLs Las estare programando en la app core . 2.1 Vista Login Para hacer el login de nuestros usuarios usaremos los siguientes paquetes propios de django from django.contrib.auth import login, authenticate los que acabamos de importar son funciones, y siempre es bueno saber que es lo que estan haciendo esas funciones, para hacerlo, con vscode basta con poner el cursor por encima de la funcion y darle click manteniento el boton de ctrl . Tu puedes modificar el uso de la funcion login de django para que cumpla con las necesidades o explorar, puede que encuentres como mejorar el codigo o una vulnerabilidad y tu reporte puede ayudar a mantener django seguro :) Ahora, crearemos nuestra vista para el login de usuarios: def login_view(request): if request.method == 'GET': # validar que el usuario no este autenticado if request.user.is_authenticated: # Redirigir a la p\u00e1gina principal si ya est\u00e1 autenticado return HttpResponse(\"Already logged in\", status=200) return render(request, 'LoginView.html') elif request.method == 'POST': username = request.POST['username'] password = request.POST['password'] user = authenticate(request, username=username, password=password) if user is not None: login(request, user) messages.success(request, 'Login successful') # Redirigir a la p\u00e1gina principal despu\u00e9s del inicio de sesi\u00f3n return HttpResponse(\"Login successful\", status=200) else: return HttpResponse(\"Invalid credentials\", status=401) La funcion authenticate nos sirve para validar las credenciales. La funcion login se encarga de crear la sesion del usuario. puedes encontrar mas informacion en la documentacion oficial de django Seguido a esto debemos de agregar nuestras urls. En el archivo settings.py agrega las siguientes variables # Login Variables LOGIN_URL = 'login' LOGOUT_REDIRECT_URL = 'login' 2.2 Vista Logout Para hacer el logout de nuestros usuarios usaremos el siguiente paquete propio de django from django.contrib.auth import logout def logout_view(request): if not request.user.is_authenticated: return redirect('login') logout(request) return HttpResponse(\"Logged out successfully\", status=200)","title":"Usuarios, Autenticaci\u00f3n y Perfiles"},{"location":"primeros-pasos/usuarios-autenticacion-perfiles/#modificacion-del-modelo-de-usuario-tradicional","text":"","title":"Modificacion del modelo de usuario tradicional"},{"location":"primeros-pasos/usuarios-autenticacion-perfiles/#1-modelo-de-auditorias","text":"A mi me gusta crear una app en django que se llame core , la cual, como su nombre lo dice, sera la app que utilizare para todo el nucleo de mi sistema y para iniciar me gusta siempre crear dos cosas: Un modelo que me sirva para ampliar los campos del modelo UserModel de django. Un modelo abstracto que tenga campos de auditoria, estos campos ya seran a necesidad de tu sistema pero yo siempre pongo campos como: Fecha de creacion, Fecha de modificacion, Usuario creacion, Usuario Modificacion y un campo que muestre si el registro esta activo o no (util para hacer soft delete y no perder registros en la base de datos) Entonces, como primer paso sera crear el Modelo que nos ayudara a extender el modelo de usuario que viene por defecto en django, para lograrlo haremos uso del paquete: from django.contrib.auth.models import AbstractUser y creamos nuestro modelo extendiendo de ese paquete: class UserModel(AbstractUser): pass Para este punto es recomendable que sepas utilizar el ORM de django, los metodos de las clases en python y el como funcionan los modelos en django. Ahora que ya tenemos nuestro modelo de usuario personalizado, podemos crear nuestro modelo abstracto de auditorias. Los modelos abstractos de django son una forma de decir que vamos a: crear una clase padre que contenga X campos la cual nos ayudara a que futuros modelos puedan heredar de esas clase (POO tradicional) sin que django cree la tabla abstracta en la base de datos. Para lograrlo, haremos uso de la clase Meta con la propiedad abstract = True: class AuditModel(models.Model): # Fecha created_at = models.DateTimeField(auto_now_add=True) updated_at = models.DateTimeField(auto_now=True) # Usuario created_by = models.ForeignKey( UserModel, on_delete=models.SET_NULL, null=True, blank=True, related_name='created_%(class)s_set' ) updated_by = models.ForeignKey( UserModel, on_delete=models.SET_NULL, null=True, blank=True, related_name='updated_%(class)s_set' ) active = models.BooleanField( default=True, help_text=\"Indica si el registro est\u00e1 activo.\", db_index=True, verbose_name=\"Activo\") class Meta: abstract = True Nota: El uso de %(class)s en el related_name permite que Django reemplace autom\u00e1ticamente este marcador con el nombre del modelo hijo que hereda de AuditModel , evitando as\u00ed conflictos de nombres en las relaciones inversas. Ahora solo debemos decirle a django que hemos cambiar su modelo usuario , lo cual se realiza agregando las siguientes lineas en el archivo settings.py AUTH_USER_MODEL = 'core.UserModel' Y finalmente estamos listos para hacer el makemigrations y migrate python manage.py makemigrations python manage.py migrate","title":"1. Modelo de auditorias"},{"location":"primeros-pasos/usuarios-autenticacion-perfiles/#2-login-de-usuarios-nivel-basico","text":"Django ya viene cargado con librerias, que nos ayudan ha controlar todo el proceso de autenticacion de un usuario, estos procesos yo los seguire incluyendo en la app de core , quiere decir que tanto Vistas Modelos Templates Signals URLs Las estare programando en la app core .","title":"2. Login de Usuarios (Nivel Basico)"},{"location":"primeros-pasos/usuarios-autenticacion-perfiles/#21-vista-login","text":"Para hacer el login de nuestros usuarios usaremos los siguientes paquetes propios de django from django.contrib.auth import login, authenticate los que acabamos de importar son funciones, y siempre es bueno saber que es lo que estan haciendo esas funciones, para hacerlo, con vscode basta con poner el cursor por encima de la funcion y darle click manteniento el boton de ctrl . Tu puedes modificar el uso de la funcion login de django para que cumpla con las necesidades o explorar, puede que encuentres como mejorar el codigo o una vulnerabilidad y tu reporte puede ayudar a mantener django seguro :) Ahora, crearemos nuestra vista para el login de usuarios: def login_view(request): if request.method == 'GET': # validar que el usuario no este autenticado if request.user.is_authenticated: # Redirigir a la p\u00e1gina principal si ya est\u00e1 autenticado return HttpResponse(\"Already logged in\", status=200) return render(request, 'LoginView.html') elif request.method == 'POST': username = request.POST['username'] password = request.POST['password'] user = authenticate(request, username=username, password=password) if user is not None: login(request, user) messages.success(request, 'Login successful') # Redirigir a la p\u00e1gina principal despu\u00e9s del inicio de sesi\u00f3n return HttpResponse(\"Login successful\", status=200) else: return HttpResponse(\"Invalid credentials\", status=401) La funcion authenticate nos sirve para validar las credenciales. La funcion login se encarga de crear la sesion del usuario. puedes encontrar mas informacion en la documentacion oficial de django Seguido a esto debemos de agregar nuestras urls. En el archivo settings.py agrega las siguientes variables # Login Variables LOGIN_URL = 'login' LOGOUT_REDIRECT_URL = 'login'","title":"2.1 Vista Login"},{"location":"primeros-pasos/usuarios-autenticacion-perfiles/#22-vista-logout","text":"Para hacer el logout de nuestros usuarios usaremos el siguiente paquete propio de django from django.contrib.auth import logout def logout_view(request): if not request.user.is_authenticated: return redirect('login') logout(request) return HttpResponse(\"Logged out successfully\", status=200)","title":"2.2 Vista Logout"},{"location":"produccion/preparar-produccion/","text":"Preparar nuestro sistema para produccion","title":"Configuraci\u00f3n para Producci\u00f3n"},{"location":"produccion/preparar-produccion/#preparar-nuestro-sistema-para-produccion","text":"","title":"Preparar nuestro sistema para produccion"}]}